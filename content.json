[{"title":"使用Prometheus来监控前端指标","date":"2019-08-31T13:16:13.000Z","path":"2019/08/31/frontend-metrics-to-prometheus/","text":"前言网上关于前端监控的文章其实已经层出不穷，这篇稍微写些不一样的。近年来prometheus打开的实时指标监控的新路子越来越被大家接受，都纷纷开始基于prometheus来搞自己的监控警报体系。我们公司也是大规模使用prometheus来搞指标监控，最近打算把前端的指标也接进来，我也趁这个机会写个简单的demo以及一些思考。 使用prometheus的优势与弊端在过去我们公司是使用elastic search来存储前端发送的事件以及处理后的数据，使用ES有个好处，可以直接满足我们两种需求：查原文和查聚合指标。本文要讨论的prometheus并不能取代ES，因为在前端监控的产品中查原文是必不可少的（比如重现某个用户的资源请求情况、查错误日志等），但是prometheus在查聚合指标时会比ES快很多，尤其是算百分位数时，相比ES的龟速，prometheus接近实时的速度可以说是最大的亮点。 当然考虑到prometheus会带来额外的开发成本，如果使用ES可以满足需求那只用ES就可以了。 整体架构由于Prometheus是主动拉取指标的模式，所以我们需要一个类似pushgateway的服务来接收前端发来的事件并将指标聚合暴露给prometheus。整体如下 infra 为了方便起见，下面实现的demo不会实现虚线部分。 前端采集第一步当然就是实现前端采集指标的部分，我们通常关心下面几类指标： 资源和页面性能指标这类指标可以通过performance.getEntries()直接拿到，其中PerformanceResourceTiming和PerformanceNavigationTiming两个类分别包含普通资源和当前页面的性能指标，同时也可以得到paint和自定义的timing。 其中要注意的是PerformanceResourceTiming会同时包含所有ajax请求，如果你不想在这里采集到ajax指标的话可以通过initiatorType !== &#39;fetch&#39; &amp;&amp; initiatorType !== &#39;xmlhttprequest&#39; &amp;&amp; initiatorType !== &#39;beacon&#39;过滤掉。 可以参考下图创建对应的指标 监听PerformanceEntry变化通常我们会在页面加载完时获取资源指标，但是如何取监听后续新的资源呢？ 最直观的方法就是使用PerformanceObserver来监听，如果要考虑兼容性的话可以使用polyfill或者用setInterval定时获取entries并筛选出新的。 AJAX指标如果你需要通过一些详细数据（比如header、request body等）作为labels的话，就需要额外监听ajax请求了，方法是覆盖默认的fetch以及XMLHttpRequest。 错误指标建议走自定义指标或者ES的聚合 自定义指标约定好数据结构发送给聚合服务即可 Example对于资源指标，我基于PerformanceObserver写了一个采集器。 对于自定义指标，由于我这里不会实现指标配置服务，所以使用了promjs这个库，但是这个库只有文本格式的输出，所以我又写了个promjs-export来导出结构化的数据，并以此作为前后端通讯的结构。 使用示例，代码如下 import { initCollector } from &#39;performance-resource-collector&#39;; import prom from &#39;promjs&#39;; import { exportMetrics } from &#39;promjs-export&#39;; const registry = prom(); const unsupportedCounter = registry.create(&#39;counter&#39;, &#39;collector_unsupported_total&#39;, &#39;A counter for browser support for collector&#39;); const setupCounter = registry.create(&#39;counter&#39;, &#39;collector_setup_total&#39;, &#39;A counter for collector setup&#39;); function sendMetrics() { navigator.sendBeacon(&quot;http://localhost:8080/custom_metrics&quot;, JSON.stringify(exportMetrics(registry))); registry.reset(); } initCollector({ // 将2s内新的资源batch调用 callback: (entries) =&gt; { navigator.sendBeacon(&quot;http://localhost:8080/resources&quot;, JSON.stringify(entries)) }, // 当前浏览器不支持PerformanceObserver onUnsupported: () =&gt; { unsupportedCounter.inc(); sendMetrics(); }, // 监听成功 onSetUp: () =&gt; { setupCounter.inc(); sendMetrics(); }, throttle: 2000, }); 指标聚合服务我们需要实现3个接口：接收PerformanceEntry的接口、接收自定义指标的接口和返回规定指标格式给prometheus的接口。 资源聚合接口资源聚合接口比较简单，因为是固定的指标，可以预先定好需要哪些指标、哪些维度，之后在代码里直接写死就好。 自定义指标聚合接口自定义指标的聚合会比较复杂，主要是因为官方实现的client是不能修改label个数的，你可能需要自己实现一个能merge的版本。 或者采用预定义指标的形式，也就是需要一个额外的指标配置服务。 指标配置 Example因为是个demo，于是就用rust来实现了，项目地址。 这里我只聚合了资源中的duration指标以及自定义的Counter类型的指标。 另外有点需要注意的是如果是用sendBeacon来发送事件的话，chrome目前是不允许我们修改Content-Type的，所以后端的web框架可能就不会自动解析json body了，需要手动parse一下。 一个完整的demo接下来让我们搭一个完整的demo来看看效果如何。 先把frontend-metrics-aggregation通过cargo run跑起来。 然后到metrics-collector里执行npm run pkg将example打包生成单个js。接着通过tampermonkey创建一个脚本，把前面生成的js替换进去。修改@match为想监控的网站，比如http*://*/*来监控所有站点。 最后下载prometheus，修改prometheus.yml，在最后一行的targets里添加一项&#39;localhost:8080&#39;，并执行prometheus即可。 随便访问些网站，打开http://localhost:9090/graph，查询`histogram_quantile(0.95, sum(rate(resource_duration_milliseconds_bucket[1h])) by (le))`就能查看到数据了。 查询duration的P95 一些问题使用资源的name作为label可能会导致high cardinality问题，导致查询变得很慢，你可以看到上面例子里查询一个小时的P95已经需要5秒了，此时name数量大概是4500。所以建议不要采集一些易变的、带参数的资源，比如下面在B站采集的一些图片。","tags":[{"name":"前端监控","slug":"前端监控","permalink":"https://frezc.github.io/tags/前端监控/"},{"name":"monitor","slug":"monitor","permalink":"https://frezc.github.io/tags/monitor/"},{"name":"prometheus","slug":"prometheus","permalink":"https://frezc.github.io/tags/prometheus/"}]},{"title":"一篇文章带你理解和使用Prometheus的指标","date":"2019-08-03T02:57:04.000Z","path":"2019/08/03/prometheus-metrics/","text":"Why prometheus实时指标是监控中最重要的一环，用来尝出实时监控图表以及触发警报。传统的指标收集方式是通过采集的日志流处理写入时序数据库（比如Druid），这样做的问题一是流程比较长，任何一环出问题就会导致监控不可用，而警报对稳定性的要求是非常高得；二是存储成本和查询速度，比如我将每次的请求耗时保存下来，那么每次请求都是一条记录，一天下来可能就有千万级别的记录，查询时对机器的性能会有一定的要求。 Prometheus直接采集服务暴露的指标，少了中间流程能大大减少出问题的概率。另外通过提供client在采集端做了预聚合，虽然这样损失了精确度，但大大减少数据量以及提升查询速度。 Prometheus所做的预聚合使得其和传统的时序数据库查询完全不同，所以认识和理解指标是使用Prometheus的第一步。下面我会解释各种指标类型以及如何去使用。 Metric types下面我主要会以Prometheus的自监控指标举例，你可以自己安装一个来尝试。 CounterCounter可以简单理解为计数器，是个比较简单但又常用的类型。适用于生成请求次数、错误次数等指标。 比如prometheus暴露的http请求次数指标如下（打开/metrics查看） # HELP prometheus_http_requests_total Counter of HTTP requests. # TYPE prometheus_http_requests_total counter prometheus_http_requests_total{code=&quot;200&quot;,handler=&quot;/api/v1/label/:name/values&quot;} 7 prometheus_http_requests_total{code=&quot;200&quot;,handler=&quot;/api/v1/query&quot;} 19 prometheus_http_requests_total{code=&quot;200&quot;,handler=&quot;/api/v1/query_range&quot;} 27 prometheus_http_requests_total{code=&quot;200&quot;,handler=&quot;/graph&quot;} 11 prometheus_http_requests_total{code=&quot;200&quot;,handler=&quot;/metrics&quot;} 8929 prometheus_http_requests_total{code=&quot;200&quot;,handler=&quot;/static/*filepath&quot;} 52 prometheus_http_requests_total{code=&quot;302&quot;,handler=&quot;/&quot;} 1 prometheus_http_requests_total{code=&quot;400&quot;,handler=&quot;/api/v1/query_range&quot;} 6 指标由指标名、花括号里的labels以及指标值组成，labels可以理解为维度，上面的数据写成表格就很好理解了。 code handler prometheus_http_requests_total 200 /api/v1/label/:name/values 7 200 /api/v1/query_range 27 200 /graph 11 200 /metrics 8929 200 /static/*filepath 52 302 / 1 400 /api/v1/query_range 6 我们可以通过/graph页面来查询这个指标，直接查询如下的instant query就可以看到过去一段时间每个采集点(默认15s)采集到的counter值。 prometheus_http_requests_total 用例Counter类型直接查询没有什么意义，通常我们要看的是过去一段时间的统计数据，可以这么查 prometheus_http_requests_total - prometheus_http_requests_total offset 1h 打开Console Tab，就能看到过去一个小时内prometheus http请求的次数统计了。 时间粒度如果熟悉传统的时序数据库查询的话，会更习惯指定时间粒度来聚合一个时间窗口内的数据。prometheus的counter指标里倒不需要做这样聚合，但为了使结果显示成每个时间粒度一个点而不是像现在的十几秒一个点，可以使用step来指定精度。 假设我们要查过去一小时内每5分钟有多少次请求可以这么写。这里使用更常用的increase函数和range query increase(prometheus_http_requests_total[5m]) 然后将Res里填上300就能得到想要的结果了。 按维度聚合除了时间粒度外还有个很常用的参数叫group by，用来按某些维度来分组聚合指标。在prometheus里做起来差不多，不过稍有限制。我们先看看怎么计算所有http请求的和。 sum(increase(prometheus_http_requests_total[5m])) 这里将上节的promql加了一层sum函数，可以看到结果只有一条线了，这条线上的每一个点就是当前时间上所有code和handler对应指标的总和。 那么如何看每个code对应的请求数呢？我们可以通过by来实现，写法很像sql。 sum(increase(prometheus_http_requests_total[5m])) by (code) 要注意的是这里by只能跟在聚合函数后面，见文档。 GaugeGauge是一个用来记录实时值的指标，常用于表示CPU使用率、内存使用率、线程数等指标。 比如prometheus暴露的go协程数指标 # HELP go_goroutines Number of goroutines that currently exist. # TYPE go_goroutines gauge go_goroutines 40 用例gauge类型指标最常见的就是用来标识服务是否存活的up指标了，这个指标在大多的exporter上都会有，属于一个可以建通用警报规则的指标。 大多数gauge指标用法差不多，我就拿go_goroutines来举例。查询go_goroutines我们可以看到一些自动生成的labels，主要关注instance，这个代表了我们的prometheus实例。假设我们有prometheus实例并且想查询所有实例的平均协程数。 avg(go_goroutines) 熟悉Prometheus后你会发现 avg 基本只对 gauge 指标有意义 按时间聚合上面的结果看起来是满足要求，但是多查几次就发现好像结果有点不太一样？（如果你看不出来可以将Res调大） 原因是prometheus的精度问题，毕竟只有15s一个点，那么我要算某个时间点的平均值肯定是无法拿到准确值的。为了减小数据偏差，可以先横向将一段时间内的数据聚合，再纵向算平均值。比如先以1分组为粒度算出每分钟的平均数，再算出所有实例的平均数。 avg(avg_over_time(go_goroutines[1m])) 预测磁盘空间这是个很有意思的使用场景，可以通过磁盘使用空间来预测。因为磁盘使用空间不像内存使用量和线程数那样变化频繁，具有一定的局部单调性，所以可以通过线性回归预测，prometheus提供了predict_linear来帮助计算。 # 利用过去30分钟的数据预测1小时后的数据 predict_linear(disk_used_bytes[30m], 3600) Histogram顾名思义该指标生成的是直方图数据。 prometheus暴露的请求耗时指标如下 # HELP prometheus_http_request_duration_seconds Histogram of latencies for HTTP requests. # TYPE prometheus_http_request_duration_seconds histogram prometheus_http_request_duration_seconds_bucket{handler=&quot;/api/v1/query_range&quot;,le=&quot;0.1&quot;} 60 prometheus_http_request_duration_seconds_bucket{handler=&quot;/api/v1/query_range&quot;,le=&quot;0.2&quot;} 63 prometheus_http_request_duration_seconds_bucket{handler=&quot;/api/v1/query_range&quot;,le=&quot;0.4&quot;} 64 prometheus_http_request_duration_seconds_bucket{handler=&quot;/api/v1/query_range&quot;,le=&quot;1&quot;} 65 prometheus_http_request_duration_seconds_bucket{handler=&quot;/api/v1/query_range&quot;,le=&quot;3&quot;} 65 prometheus_http_request_duration_seconds_bucket{handler=&quot;/api/v1/query_range&quot;,le=&quot;8&quot;} 65 prometheus_http_request_duration_seconds_bucket{handler=&quot;/api/v1/query_range&quot;,le=&quot;20&quot;} 65 prometheus_http_request_duration_seconds_bucket{handler=&quot;/api/v1/query_range&quot;,le=&quot;60&quot;} 65 prometheus_http_request_duration_seconds_bucket{handler=&quot;/api/v1/query_range&quot;,le=&quot;120&quot;} 65 prometheus_http_request_duration_seconds_bucket{handler=&quot;/api/v1/query_range&quot;,le=&quot;+Inf&quot;} 65 prometheus_http_request_duration_seconds_sum{handler=&quot;/api/v1/query_range&quot;} 2.5237541999999995 prometheus_http_request_duration_seconds_count{handler=&quot;/api/v1/query_range&quot;} 65 # 其他labels下的都删掉了 prometheus_http_request_duration_seconds使用了[0.1,0.2,0.4,1,3,8,20,60,120,+Inf]这几个分桶来采样数据。 用例通常我们会使用该数据来计算百分位数。 比如我们可以通过以下的promql查询prometheus_http_request_duration_seconds在过去1小时内的P95（95%的请求耗时都小于等于这个值）。 histogram_quantile(0.95, rate(prometheus_http_request_duration_seconds_bucket[1h])) 如果出现了NaN数据代表数据量不够，无法计算。 如果有多个prometheus实例，同样可以聚合计算P95 # 注意group by le，防止把分桶信息也聚合了 histogram_quantile(0.95, sum(rate(prometheus_http_request_duration_seconds_bucket[1h])) by (le)) SummarySummary类型是在客户端直接聚合生成的百分位数。 比如Prometheus抓取间隔的百分位数指标 # HELP prometheus_target_interval_length_seconds Actual intervals between scrapes. # TYPE prometheus_target_interval_length_seconds summary prometheus_target_interval_length_seconds{interval=&quot;15s&quot;,quantile=&quot;0.01&quot;} 14.9986389 prometheus_target_interval_length_seconds{interval=&quot;15s&quot;,quantile=&quot;0.05&quot;} 14.9991762 prometheus_target_interval_length_seconds{interval=&quot;15s&quot;,quantile=&quot;0.5&quot;} 15.0000115 prometheus_target_interval_length_seconds{interval=&quot;15s&quot;,quantile=&quot;0.9&quot;} 15.0006213 prometheus_target_interval_length_seconds{interval=&quot;15s&quot;,quantile=&quot;0.99&quot;} 15.0010902 prometheus_target_interval_length_seconds_sum{interval=&quot;15s&quot;} 178380.0282111002 prometheus_target_interval_length_seconds_count{interval=&quot;15s&quot;} 11892 虽然Histogram也能计算百分位数但精度受分桶影响很大，分桶少的话会使百分位数计算很不准确，而分桶多的话会使数据量成倍增加。Summary则是依靠原始数据计算出的百分位数，是很准确的值。 但是平时一般不用Summary，因为它无法聚合。想象一下，prometheus抓取了一个集群下多台机器的百分位数，我们怎么根据这些数据得到整个集群的百分位数呢？如果是P0（最小值）和P100（最大值）是可以计算，分别计算所有机器P0的最小值以及P100的最大值就行，但是其他百分位数就束手无策了。 所以除非你真的需要精确的百分位数，否则不建议使用Summary。 Reference https://prometheus.io/docs/concepts/metric_types/ https://prometheus.io/docs/practices/histograms/ http://latencytipoftheday.blogspot.de/2014/06/latencytipoftheday-you-cant-average.html","tags":[{"name":"monitor","slug":"monitor","permalink":"https://frezc.github.io/tags/monitor/"},{"name":"prometheus","slug":"prometheus","permalink":"https://frezc.github.io/tags/prometheus/"},{"name":"监控","slug":"监控","permalink":"https://frezc.github.io/tags/监控/"}]},{"title":"leetcode #84 直方图内最大矩形解题思路","date":"2019-05-25T13:21:43.000Z","path":"2019/05/25/leetcode-largest-rectangle-in-histogram/","text":"题目：https://leetcode.com/problems/largest-rectangle-in-histogram/ 网上也有很多人写了解法了，但是我认为都没有把思路写清楚，需要花一些时间来理解。我写这篇文章主要也是记录一下我自己的思路，希望给人以启发。 这道题被打上了 stack 的标签，大概是因为栈的解法十分巧妙，但是解这道题栈不是重点，想清楚了我们也能用其他的解法。 拆分子问题这道题一开始我的想法是用DP来做，想通过0~i的最大值来依次推算，可是想不出递推式。后来发现是我子问题就想错了。 这道题有点像木桶装水，我们可以发现一个区间内的最大矩形的高度一定是受限于这个区间内的最小高度。反过来想，对于每个高度的柱子也一定会有一个区间是以其作为最小高度的，那么我们可以得到需要的子问题，就是找出某个高度作为最小高度时所对应的最大区间，通过对每个高度的子问题求解就能推算出所有高度的最大区间，也就是该问题的解了。 下图中我把每个高度对应的最大区间标识了出来 每个最小高度对应的最大区间 找到每个高度对应的最大区间遍历最直观的方法就是从当前柱子开始向两侧遍历，找到第一个小于当前高度的柱子，分别就是两侧的边界了。因为如果这个区间包含了比当前高度还小的柱子的话，当前的高度就不是最小高度了。 当然这种方法会使时间复杂度为O(n²)，对于这道题来说会超时。下面是优化这个子问题解法的方案。 DPDP的解法比较易懂，这里拿heights = [2,4,3,1]来举例说明，下面用i来表示每项索引： i = 0: 对于第一个高度的左边界设为-1。我们在数组里存下当前索引对应的边界索引，dp = [-1] i = 1: 由于第一个高度2小于第二个高度4，我们就能直接得到，第二个高度的左边界0。dp = [-1,0] i = 2: 当前高度3小于前一个高度4，所以我们继续拿前一个索引对应的左边界(dp[1]也就是i = 0)来判断，3 &gt; heights[0]，所以当前高度的左边界就是0。dp = [-1,0,0] i = 3: 同上，我们直接拿dp[2]也就是i = 0比较，发现1还是比较小。再取dp[0] = -1，该索引已经超出数组边界了，所以得到当前左边界 dp[3] = -1。 在第4步中，我们通过DP构建的数组跳过了一次判断，在比较庞大的数据中能减少更多的判断，这也是为什么DP能将O(n²)优化至O(n)。 得到左侧边界数组后我们还需要构建右侧边界数组，方法同上只不过需要倒过来生成。 Stack还有一种通过栈的方式来快速得到左右边界的方法，这种方法需要将索引压入栈内，并使栈内的元素保持单调递增，这样就能保证栈内每个高度的前一个高度就是这个当前高度的左边界。同时如果要压入栈内的高度比栈顶高度小，那么这个高度就是栈顶高度的右边界，这样我们就将栈顶高度的左右边界算好了，将其抛弃即可，继续比较下一个栈顶高度。 同样拿上面的[2,4,3,1]举例 i = 0，栈为空，压入第一个索引0。stack = [0] i = 1，4 &gt; 2，压入第二个索引。stack = [0,1] i = 2，3 &lt; 4，这个时候我们可以得到栈顶索引1对应的左右边界[0,2]，可以直接算出面积。弹出1，stack = [0] i = 2，继续比较栈顶元素3 &gt; 2，压入2。stack = [0,2] i = 3，1 &lt; 3，同理栈顶索引2的左右边界为[0,3]，弹出继续得到栈顶0的左右边界[-1,3]。stack = [] 栈为空压入3。stack = [3] 遍历完后将栈顶元素依次弹出，3的左右边界为[-1,4] 其他解法有人也提出了分治的解法，相比O(n)的解法比较直白，更像是直接遍历的优化。 #85 Maximal Rectangle由于85的解法是基于该题，所以顺便提一下。 这道题的关键点也是如何拆子问题，我们可以遍历所有rows，对于每一行将其作为底边，计算上面&#39;1&#39;组成柱子的最大矩形，这样就可以利用前一道题的解法来解决这个子问题了，最后对所有子问题的解算出最大值即可。 当然如果没有84直接做这道题应该会很难想到这种拆子问题的方法。。","tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://frezc.github.io/tags/algorithm/"}]},{"title":"React & React-Hooks & Typescript 快速入门 (draft)","date":"2019-05-15T16:24:43.000Z","path":"2019/05/16/typescript-react-hooks-quickstart/","text":"9102年了, 学习React其实完全可以从react-hooks开始, 这也是我写这篇文章的初衷。 另外我也希望能用比较简洁的语言来解释一些相关的原理, 不过本文还是会以如何使用为主, 所以比较适合想了解个大概后快速上手去写的人。 本文主要内容是解释如何基于Typescript来写React组件, 需要你有javascript基础, 对html有一定的认识。 准备环境开发环境已经装过的可以跳过 安装node 8.10以上的版本, 最好就用最新版 安装yarn 修改yarn的registry, 执行下列命令即可yarn config set registry http://registry.npm.taobao.org/ 安装vscode, 这是对ts支持最好的editor了, 没必要用其他的 创建项目你可以使用已有的项目, 或者parcel, webpack等其他构建工具。 $ mkdir react-quickstart &amp;&amp; cd react-quickstart $ yarn create umi 为了使项目结构简单一点，这里选择app，并选择使用typescript，最后勾选antd。 然后将src/layouts 和 src/pages 下的文件都删掉，然后在src/pages下创建index.jsx，加上以下内容。 import * as React from &quot;react&quot;; export default function Index() { return &lt;span&gt;hello world&lt;/span&gt;; }; yarn install yarn start 打开 http://localhost:8000/, 就能在屏幕上看到 hello world 了。 React入门认识组件使用react你唯一需要做的事情就是写组件, react里的组件和其他UI框架差不多, 就是封装了一系列UI和行为的代码. 上面我们在src/pages/index.jsx里定义了一个页面, 这个页面本身就是一个组件. 在react里定义一个组件的方法如下 // FC is Function Component function Index() { return &lt;span&gt;hello world&lt;/span&gt;; }; 没错, 组件就是一个函数(让我们先忽视类的写法), 对于没有状态的组件我们可以将其当作一个纯函数. 比如下面我们用ts来申明组件的参数： const Index: React.FC&lt;{ name: string; }&gt; = (props) =&gt; { return &lt;span&gt;hello {props.name}&lt;/span&gt;; }; 这个组件有一个 参数 用户名(输入), 以及对应返回的Virtual DOM(输出). Inversion of ControlReact是一个典型的IoC框架, 我们只要写好组件交付给React, 它能帮我们处理好UI(HTML DOM)的创建, 更新和销毁. 组件 React Properties -------&gt; Virtual DOM --------&gt; HTML DOM JSX(TSX)上面例子里每个组件都返回了类似HTML的表达式, 这就是JSX. 我觉得官方文档讲得挺清楚了，你可以花几分钟看一下。另外这篇文档讲得比较详细，建议简单看一遍，遇到了问题可以多查阅。 你只要理解下面两点就能完全掌握JSX： JSX本身就是JS表达式(Expression) JSX里可以在参数部分（包括children参数）用花括号({和})内嵌JS表达式。 JSX范式下面列了一些比较常见的JSX写法 条件渲染 在组件内`jsxfunction MyComponent(props) {if (props.visible) { return ‘Hi, I\\’m visible.’;} return ‘I\\’m invisible now.’;} // Hi, I\\’m visible. // I\\’m invisible now. // I\\’m invisible now. 2. 在JSX内，会用到花括号嵌入JS表达式来实现。由于JS中`if..else..`不是表达式，所以会使用逻辑运算符(`&amp;&amp;`或`||`)和三元表达式(`.. ? .. : ..`) ```jsx function Greeting(props) { return ( &lt;span style={{ color: 'red' }}&gt; {props.lang === &#39;janpanese&#39; ? &#39;こんにちは&#39; : &#39;Hello&#39;} {props.emphasis &amp;&amp; &#39;!&#39;} &lt;/span&gt; ); } &lt;Greeting /&gt; // &lt;span&gt;Hello&lt;/span&gt; &lt;Greeting lang=&quot;janpanese&quot; /&gt; // &lt;span&gt;こんにちは&lt;/span&gt; &lt;Greeting lang=&quot;janpanese&quot; emphasis /&gt; // &lt;span&gt;こんにちは!&lt;/span&gt; 列表渲染把一系列数据渲染一个列表或者表格也是相当常见的需求，在JSX里我们可以使用数组上的map方法来实现 function Ranking(props) { return ( &lt;div&gt; {props.value &amp;&amp; props.value.map((name, index) =&gt; ( // 这里需要给列表每一项加上一个id &lt;div key={index}&gt;{index + 1}. {name}&lt;/div&gt; ))} &lt;/div&gt; ) } &lt;Ranking /&gt; // &lt;div&gt;&lt;/div&gt; &lt;Ranking value={[]} /&gt; // &lt;div&gt;&lt;/div&gt; &lt;Ranking value={[&#39;dio&#39;, &#39;kars&#39;, &#39;kirayoshikage&#39;, &#39;Diavolo&#39;]} /&gt; /* output: &lt;div&gt; &lt;div&gt;1. dio&lt;/div&gt; &lt;div&gt;2. kars&lt;/div&gt; &lt;div&gt;3. kirayoshikage&lt;/div&gt; &lt;div&gt;4. Diavolo&lt;/div&gt; &lt;/div&gt; */ 这个例子有两个小技巧： 利用&amp;&amp;来判空，兼容value未传入的情况(此时value === undefined)。因为这里没有定义参数类型，使用者可能会传入任何值，所以需要做一些简单处理。不过在使用typescript后就不存在这种问题了。 map中传入的箭头函数其实是以下函数的缩写，(name, index) =&gt; { return ( &lt;div&gt;{index + 1}. {name}&lt;/div&gt; ); } 为什么渲染列表时需要传入key这个参数这是由于React的diff算法所决定的，我们需要给列表中每项一个在当前列表内的唯一ID。你可以参考这篇文章来选择key。 封装复杂的渲染逻辑当你在一个组件内的JSX写得越来越复杂时，可以将部分逻辑抽离出来单独写一个组件，如果你认为这些逻辑没什么可复用性，再写一个组件要传很多参数比较麻烦，那么单独抽离成一个函数也可以。 function ComplexComponent() { // some state code... const displayType = ...; function renderChart() { // codes } function renderTable() { // codes } return ( &lt;div className=&quot;some-layout-style&quot;&gt; &lt;div&gt; { /* some complex jsx */ } &lt;/div&gt; {displayType === &#39;chart&#39; ? renderChart() : renderTable()} &lt;/div&gt; ) } 有时候也可以将组件里一些重复用到的JSX写到一个函数内 function TopOfTheYear(props) { function renderRank(value) { return value &amp;&amp; value.map((name, index) =&gt; ( &lt;div&gt;{index + 1}. {name}&lt;/div&gt; )); } return ( &lt;div&gt; &lt;div&gt;ANIMES:&lt;/div&gt; {renderRank(props.animes)} &lt;div&gt;MOVIES:&lt;/div&gt; {renderRank(props.movies)} &lt;/div&gt; ) } 出现嵌套列表时也可以递归调用，比如下面递归渲染的树 function Tree(props) { function renderTreeNodes(nodes) { return nodes.map((node, i) =&gt; ( &lt;div className=&quot;children&quot;&gt; {node.name} {nodes.children &amp;&amp; ( &lt;div className=&quot;children&quot;&gt; {renderTreeNodes(nodes.children)} &lt;/div&gt; )} &lt;/div&gt; )) } return ( &lt;div className=&quot;tree-root&quot;&gt; {props.value &amp;&amp; renderTreeNodes(props.value)} &lt;/div&gt; ); } 通常我们在刚写jsx时会有疑惑，为什么需要import react？因为JSX被编译出来的JS表达式会使用React，比如下面的例子 // 编译前 const virtualDom = ( &lt;MyButton color=&quot;blue&quot; shadowSize={2}&gt; Click Me &lt;/MyButton&gt; ); // 编译后 const virtualDom = React.createElement( MyButton, { color: &#39;blue&#39;, shadowSize: 2 }, &#39;Click Me&#39; ); 这里编译后不会自动帮我们加上import，所以需要我们手动加了。如果你不喜欢手动写import，可以通过配置打包工具来少些几行代码，比如webpack的配置方法。 这个其实在上面的文档里就有解答，遇到了问题多看看文档。 状态上面我们写的都是纯函数组件，但是大部分情况组件都会有内部状态，下面让我们看看怎么给组件添加状态。 PS: 有状态的组件称为函数组件 引入状态对应的API是React.useState，看下面的例子 import { useState } from &#39;react&#39;; function Counter() { // 这里声明了我们要使用一个初始值为 0 的状态 const [count, setCount] = useState(0); // count只有在第一次渲染时使用初始值，之后都是内部维持的状态 // setCount用来更新状态 return ( &lt;div&gt; &lt;div&gt;count: {count}&lt;/div&gt; &lt;button onClick={() =&gt; setCount(count + 1)} &gt;+&lt;/button&gt; &lt;/div&gt; ) } 复杂状态有时候状态可能是个复杂的对象，和上面用法差不多，但要注意的是你只更新对象上的一个变量时，也需要生成一个新对象。 只是简单更新单层对象可以参考以下范式 const obj1 = { a: 1, b: 2 }; // 解构 const obj2 = { ...obj1, b: 3 }; // { a: 1, b: 3 } // Object.assign方法 const obj3 = Object.assign({}, obj1, { a: 2 }); // { a: 2, b: 2 } 例子 import { useState } from &#39;react&#39;; function Counter() { const [state, setState] = useState({ count: 0, other: &#39;a&#39; }); return ( &lt;div&gt; &lt;div&gt;count: {state.count}&lt;/div&gt; &lt;button onClick={() =&gt; setState({ // 这里setState会覆盖掉之前的状态，所以要保留other的话，需要将新旧对象合并到一起 ...state, count: state.count + 1, })} &gt;+&lt;/button&gt; &lt;/div&gt; ) } 分离逻辑（useReducer）todohttps://reactjs.org/docs/hooks-reference.html#usereducer 多个状态useState可以在一个组件中创建任意数量的状态，但你不能在条件、循环和嵌套函数里调用。 import { useState } from &#39;react&#39;; function Counter(props) { // 你只能在函数的顶级调用 const [c, s] = useState(0); // error: 不能放到任何条件block内 if (props.visible) { const [c, s] = useState(0); } // error: 同上 const [c, s] = props.visible ? useState(0) : useState(99); function renderContent() { // error: 不能在嵌套函数中调用 const [c, s] = useState(0); } // ... } 你不用死记这些，因为有eslint会帮你发现这些错误，你只要遇到了知道是什么原因就行。 为什么要按固定的顺序调用？函数组件的状态是由React帮你维护的，每次调用useState，React就会找到对应的状态返回给你，这是很经典的依赖注入的思想。 下面的例子相信很容易理解 // react 内部的状态列表 internal_state = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] const [a] = useState(&#39;a&#39;); // 返回 internal_state[0] const [b] = useState(&#39;b&#39;); // 返回 internal_state[1] const [c] = useState(&#39;c&#39;); // 返回 internal_state[2] // 如果某些原因导致顺序发生了变化，拿到的值就不正确了 const [a] = useState(&#39;a&#39;); // 返回 internal_state[0] const [c] = useState(&#39;c&#39;); // 返回 internal_state[1] const [b] = useState(&#39;b&#39;); // 返回 internal_state[2] useEffect（组件生命周期）React hook上面提到的useState、useReducer以及接下来介绍的useEffect都是React hook，hook你可以理解为函数组件内可以使用的一系列工具，通常 约定 以use开头。 如何监听生命周期如果你之前接触过React，那你可能知道一些很常用的生命周期方法，像componentDidMount（组件第一次渲染后）、componentDidUpdate（组件每次更新后）等等。 这些生命周期方法对于一个组件是非常重要的，在函数组件里我们可以使用useEffect来实现。 下面是个如何监听页面滚动的例子，我们需要在组件挂载到节点后添加事件监听，并在组件销毁时移除事件监听以免内存泄漏。 import { useEffect } from &#39;react&#39;; function MyComponent() { // 滚动事件的监听函数 function scrollHandler() {} // 基本等同于componentDidMount useEffect(() =&gt; { document.addEventListener(&#39;scroll&#39;, scrollHandler); // 这里返回的函数会在组件销毁前被调用 return () =&gt; { document.removeEventListener(&#39;scroll&#39;, scrollHandler); }; }, []); return &lt;div&gt;...&lt;/div&gt; } useEffectuseEffect会接收两个参数，第一个参数是一个函数A，其会在适当的时机被调用，该函数如果返回了一个函数B，函数B被称为clean up函数，B会在下一次A被调用前或者组件销毁前被调用。 第二个参数用来提示A的调用时机，通常有3种情况： 传入undefined(等同不传)：这种情况会在每次渲染时调用A，可以理解为在组件首次渲染或者更新时调用。 这种情况使用得不多，通常用来手动跟踪某些值和节点的变化。 传入[]：这种情况会在组件首次渲染时调用。 通常用于组件内发起一次性的请求。 const [result, setResult] = useState(); const [loading, setLoading] = useState(true); useEffect(() =&gt; { // 这里你不能直接使用async function，因为它会返回的Promise会被误认为cleanup函数 async function fn() { setResult(await fetchSomething()); setLoading(false); } fn(); }, []) 传入非空数组：在2的基础上，如果数组中任意值发生了变化，就会去调用。 通常用来监听某些状态的变化并执行一些副作用函数，比如将状态保存到浏览器。 const [value, setValue] = useState(() =&gt; localStorage.getItem(&#39;VALUE_ID&#39;)); useEffect(() =&gt; { // 每次value变化就会将其持久化到浏览器 localStorage.setItem(&#39;VALUE_ID&#39;, value); }, [value]); 使用typescript来写React组件为什么要用typescript?没有类型辅助写大中型项目(尤其在多人协作方面)是件心智负担很重的事, typescript是目前使用最为广泛的 compile to javascript 语言. 当然你也可以使用 flow, reasonml, elm 等语言, 不过这些不是本文的目标。 如果只想用js, 那么只需要将文件后缀改为 jsx 并且去掉所有类型即可。 本节只会解释本文会用到的ts特性, 深入可以参考推荐阅读里的内容。 你需要知道的Typescriptts里大部分时间不需要显式声明类型, 因为它能自动推断。 // 基础类型 const a: number = 1; const b: string = &#39;abc&#39;; const c: boolean = true; const d: undefined = undefined; const e: null = null; // 函数类型 function parseInt(input: string, radix?: number): number { ／* implement code */ } // 箭头函数类型 const parseInt: (input: string, radix?: number) =&gt; number = (input, radix) =&gt; { ／* implement code */ }; // Union Type let union: number | string | undefined = 1; union = undefined; // ok union = &#39;ok&#39;; // ok // 字面量类型 const f: &#39;jotaro&#39; | &#39;giorno&#39; = &#39;giorno&#39;; const g: 1 | 2 = 3; // ts will throw error // 对象字面量类型 const obj: { field: string } = { field: &#39;abc&#39; }; // 接口 interface A { message?: string; // &#39;?&#39;将会给类型添加undefined, 这里相当于 string | undefined } const h: A = { message: &#39;now&#39; }; const i: A = {}; // message is undefined const j = { message: &#39;now&#39; }; // 如果我们不加类型定义, 这里j会被推断为 { message: string } Type Compatibilityts里如果两个接口的每项参数的类型是匹配的那么, 这两个接口就是匹配的. 比如下面两个接口在ts里其实没有什么区别 interface Point { x: number; y: number; } interface Rectangle { x: number; y: number; } 这个特性主要对于经常出现的对象字面量很有帮助 interface A { message?: string; } let obj = { message: &#39;now&#39; }; // 这个对象的类型是 { message: string } // 虽然这个类型和A不是同一个类型，但是它们是兼容的, 所以这里可以将这个对象赋值给类型为 A 的变量 h. const h: A = obj; Union Type和其他字面量类型也是很符合直觉的 const a = &#39;a&#39;; const b: &#39;a&#39; | &#39;b&#39; = a; // ok const c: string | number = b; // ok const d: number = c; // error if (typeof c === &#39;number&#39;) { const e: number = c; // ok, c is number type here } 还有其他比如函数、枚举、泛型的类型匹配可以看官方文档。因为这些比较少用到，所以碰到了再看文档就行。 泛型和其他语言差不多, 在本文里就不深入解释了 import通常你会看到在很多项目的tsx文件里会这么import react import * as React from &#39;react&#39;; 这种写法是因为react本身是没有export default，而且ts不像js会默认去兼容commonjs的写法，所以你需要import entire module。如果你不喜欢这种写法，可以修改tsconfig.json来兼容。 编写可维护的组件todo 推荐阅读 React官方文档 Typescript handbook Typescript Deep Dive 常用组件和库 ant design: UI组件 lodash: 函数库 moment: 时间工具","tags":[{"name":"react","slug":"react","permalink":"https://frezc.github.io/tags/react/"},{"name":"typescript","slug":"typescript","permalink":"https://frezc.github.io/tags/typescript/"},{"name":"react-hooks","slug":"react-hooks","permalink":"https://frezc.github.io/tags/react-hooks/"},{"name":"tutorial","slug":"tutorial","permalink":"https://frezc.github.io/tags/tutorial/"}]},{"title":"相对时间表达式 —— 解决相对时间序列化的问题","date":"2019-04-26T15:21:16.000Z","path":"2019/04/26/relative-time-expression/","text":"平时开发监控系统时免不了与时序数据库的查询打交道，在查时序数据库时 时间范围 是必不可少的条件，所以在查询的UI展示上通常会将时间范围作为一个独立的组件来让用户交互。 时间范围通常会展示为两种形式：相对时间和绝对时间。对于监控系统来说，日常观察指标、建立看板基本都是使用相对时间，因为使用绝对时间的话一是不能及时更新，二是容易引发慢查询。而绝对时间的使用场景一般是定位具体问题。 在我们的监控前端里主要使用相对时间的地方有两个，一是adhoc查询，另一个是看板。在这两处需求里都需要对相对时间序列化，前者用来分享查询链接，后者用来保存看板配置。下面就谈谈如何序列化相对时间。 使用key来映射这是一开始监控里使用的方式，就是通过一些预定义的key（yesterday, today, thisweek等）来保存相对时间范围，前端在展示时需要额外写死的 Label Map 和 Duration Map。 const LabelMap = { yesterday: &#39;昨天&#39;, today: &#39;今天&#39;, thisweek: &#39;这周&#39;, // and so on.. }; const DurationMap = { yesterday: () =&gt; [moment().subtract(1, &#39;day&#39;).startOf(&#39;day&#39;), moment().subtract(1, &#39;day&#39;).endOf(&#39;day&#39;)], today: () =&gt; [moment().startOf(&#39;day&#39;), moment().endOf(&#39;day&#39;)], thisweek: () =&gt; [moment().startOf(&#39;week&#39;), moment().endOf(&#39;week&#39;)], // and so on.. } 这种方式很简单但不灵活，如果需要一个新的时间段就必须改这两个Map才行。而且如果用户有一些特殊的相对时间的话，这种方案就行不通了。 使用结构化数据为了灵活性考虑，我们可以使用对象来保存相对时间，这里我们需要先理解相对时间由什么组成。 相对时间的抽象在项目里我们一般用的时间段都是由一个开始点和一个结束点构成，其中一个相对时间点是由一连串计算产生的，这里的计算我们可以分为两类：偏移和区间首尾。对应的moment方法为 // 偏移 moment().add(1, &#39;hour&#39;); moment().subtract(1, &#39;day&#39;); // 区间首尾 moment().startOf(&#39;hour&#39;); moment().endOf(&#39;day&#39;); 实现对应的数据结构如下 type Unit = &#39;s&#39; | &#39;m&#39; | &#39;h&#39; | &#39;d&#39; | &#39;w&#39; | &#39;M&#39; | &#39;y&#39;; interface Offset { type: &#39;Offset&#39;; // 用来表示 add 或者 subtract，一般实际使用都是 subtract 所以可以省略 // op: &#39;+&#39; | &#39;-&#39;; number: number; unit: Unit; } interface Period { type: &#39;Period&#39;; // 用来表示 startOf 或 endOf，实际使用时可以使用开始和结束点来区分，所以也可以省略 // op: &#39;start&#39; | &#39;end&#39;; unit: Unit; } type Calc = Offset | Period; interface TimeRange { start: Array&lt;Calc&gt;; end: Array&lt;Calc&gt;; } 另外只要根据这个数据结构实现一个展示Label的函数和一个计算Duration的函数就行了。 结构化数据提供了很好的灵活性但暴露了几个缺点： 展示Label的函数不好写，尤其是对于两步以上的计算就得写很多特殊判断，比如 上周 我们的数据长这样(对象写起来太长，用moment表示一下)[moment().sutract(1, &#39;w&#39;).startOf(&#39;w&#39;), moment().sutract(1, &#39;w&#39;).endOf(&#39;w&#39;)]，反过来将该对象格式化就得写很多判断代码才行。 为了方便使用，肯定是需要快速筛选，无论这个列表放在前端还是后端都需要写一大堆代码（快速筛选如下） 对象不太方便放到query里，比如在我们监控看板里有一个功能，可以让用户在query里带上时间参数来覆盖看板里的默认配置，如果这里是对象的话就不太方便了。 使用相对时间表达式如果能用表达式来表示上面的结构化数据的话不就能解决以上几条缺点了吗？ 相对时间表达式在这点上Grafana已经提供了一个可用的雏形，我在其语法基础上重写了逻辑，增加了容错性以及语法特性，独立出来了一个库（主页）。这个表达式是基于上一节结构化数据实现的，但是能更简单明了。比如（取自examples） now - 12h: 12 hours ago, same as moment().subtract(12, &#39;hours&#39;) -1d: 1 day ago, same as moment().subtract(1, &#39;day&#39;) now / d: the start of today, same as moment().startOf(&#39;day&#39;) now \\ w: the end of this week, same as moment().endOf(&#39;week&#39;) now - w / w: the start of last week, same as moment().subtract(1, &#39;week&#39;).startOf(&#39;week&#39;) 如何解决结构化数据的缺陷如何解决格式化问题将表达式格式化的话特殊区间就不需要写代码进行判断了，只需像第一种方式里一样将标准格式的表达式映射到相应的文本上就行了。比如 const LabelMap = { &#39;now-d/d to now-d\\\\d&#39;: &#39;昨天&#39;, &#39;now-w/d to now-w\\\\d&#39;: &#39;上周的同一天&#39;, // so on.. } import { standardize } from &#39;relative-time-expression&#39;; const start = standardize(&#39; now - 1 d /d&#39;); // return now-d/d const end = standardize(&#39;-d\\\\d&#39;); // return now-d\\d const label = LabelMap[`${start} to ${end}`] || `${start} to ${end}`; expect(label).toEqual(&#39;昨天&#39;); 当然在处理 前x小时, 前x天 这种情况还是需要写一些判断，和上节的处理差不多，如下 // const start, end = ... import { parse } from &#39;relative-time-expression&#39;; if (end === &#39;now&#39;) { // omit error catch code const ast = parse(start); if (ast.body.length === 1 &amp;&amp; ast.body[0].type === &#39;Offset&#39;) { // 如果start只有一项偏移，那么就可以格式化成 `前{number}{单位}` 了 return `前${ast.body[0].number}${ast.body[0].unit}`; } // ... } 解决剩下两个问题值一旦变成普通字符串的话这两个问题也就迎刃而解了。 时区问题区间首尾的计算是基于时区的，比如now/d, 用户期望的通常是他所在地区一天的开始时间（当然也不排除想通过另外时区的时间查数据的情况）。如果计算相对时间实在客户端的话，浏览器其实已经帮我们设定好了正确的时区，但是服务端就不一样了，它只能拿到服务器系统所在时区的时间。 所以考虑服务端计算相对时间的需求（监控看板里就有类似需求：通过看板组件id直接调用后端接口拿到数据），客户端在调用这些接口时需要带上时区信息。服务端的处理代码如下 import parse from &#39;rte-moment&#39;; import moment from &#39;moment-timezone&#39;; const m = parse(&#39;now/d&#39;, { base: moment().tz(clientTimezone || &#39;Asia/Shanghai&#39;) }); moment().tz(&#39;Asia/Shanghai&#39;).startOf(&#39;day&#39;).isSame(m); // true 结语在监控项目里的时间组件基本参照了Grafana的时间组件，不得不说其在监控方面还有很多值得学习的地方。 另外该项目除了typescript外还用rust练手写了一遍，rust给我印象最深的一点是整套项目构建、文档生成、依赖管理的工具非常好用，上手就可以专心写代码了。","tags":[{"name":"time","slug":"time","permalink":"https://frezc.github.io/tags/time/"},{"name":"moment","slug":"moment","permalink":"https://frezc.github.io/tags/moment/"},{"name":"parser","slug":"parser","permalink":"https://frezc.github.io/tags/parser/"},{"name":"rust","slug":"rust","permalink":"https://frezc.github.io/tags/rust/"}]},{"title":"看板性能优化实践","date":"2019-04-13T06:04:47.000Z","path":"2019/04/13/dashboard-performance-optimization/","text":"最近比较有空就打算把看板的性能优化做一下，打开项目用chrome的performance记录了一下一个组件比较多的看板。这个结果还是比较让人惊讶，原本以为性能瓶颈主要在图表（G2的性能堪忧），没想到看板本身的性能也如此糟糕。 优化前的性能 本地开发环境，相比生成环境耗时多了40%，本文主要看同一环境下的对比 接下来看看如何通过这个结果进行优化。下面的章节是按必要性进行的排序。 首屏不要渲染没必要的组件我先看了下耗时接近7s的那一帧里，什么组件占了大头。发现主要是两个：即席查询的编辑组件和CMDB选择器。 测试用的看板 即席查询的编辑组件不应该被渲染，因为图表的需要依赖编辑组件里请求的数据进行渲染，但是因此把这么多组件的编辑组件给渲染出来就非常影响性能了。 这里我们把组件需要的数据移到更上一层去请求，然后除了编辑模式下不再去渲染编辑组件。 关于CMDB选择器的优化见下一节 所有组件都应该在独立的帧内渲染看板里的所有组件应该关心自己的性能，因为组件可能会是成倍出现的，渲染耗时会被成倍放大。如果很多组件碰巧在相近的时间（或者在比较长的一帧内）请求结束并去渲染结果的话，就会将一帧拖得很长。在这帧内页面会处于假死状态，用户无法滚动和交互。 在我们的看板里就有这个问题 看板组件的渲染，尤其是Chart和Table都需要对大量结果进行处理。 CMDB选择器会将所有CMDB数据组织成树状结构。（虽然这里可以改为每次只请求一级来优化，但是这样需要的改动太多了） 怎么优化呢？这里我们可以参考react fiber的实现方式，一个简单的方案就是使用requestIdleCallback这个API来将每个组件请求结束后的更新拆散到每一帧内。这样就不会出现多个组件同时更新而“撞车”的情况了。 requestIdleCallback(() =&gt; { // update component with response data }, { timeout: 2000 }); 我们可以同时应用到组件和CMDB选择器的上，但是我们又希望组件更新能早于CMDB选择器，因为比较重要。不过目前requestIdleCallback没有优先级的概念，不过可以自己实现一个。 React Concurrent ModeReact其实提供了一个类似的优化方案：concurrent mode，了解更多可以查看这篇文章。 但是我在使用concurrent mode时碰到一些问题所以暂时没用： 默认使用Strict Mode，用了一些组件库会有一堆警告 不知道是不是和旧API不兼容，用在项目里时看板组件就抛错app.5793fd45.js:6977 Uncaught TypeError: callback is not a function at flushFirstCallback (app.5793fd45.js:6977) at flushWork (app.5793fd45.js:7075) at MessagePort.channel.port1.onmessage (app.5793fd45.js:6817) 目前没有详细文档，遇到问题也不好解决 Mobx batch update因为在看板里用到了mobx所以顺便提一下，我在组件更新图表数据时使用了reaction函数，这个函数会自动对第二个参数里调用update进行batch reaction(() =&gt; toJS(this.fetchResult), () =&gt; { // auto batch all update here store.updateSource(this.fetchResult); store.updateConfig(this.fetchResult); }); 但是如果将更新放到requestIdleCallback里的话，这里就会触发两次更新了。需要手动加上action才能使其batch reaction(() =&gt; toJS(this.fetchResult), () =&gt; { // you must use action to enable batch // ↓↓↓↓↓↓ window.requestIdleCallback(action(() =&gt; { store.updateSource(this.fetchResult); store.updateConfig(this.fetchResult); }), { timeout: 3000 }); }); 懒加载经过前两步的优化后，看板加载起来已经顺畅很多了，但是看板内容（就是测试看板图上的看板组件部分）初始化时还是有1.4s的时间。 这里其实没有哪块特别耗时了，所以需要其他方法来减少渲染耗时，那么自然就想到懒加载了。就上面展示的看板在首屏时底下有一堆是看不到的，那么我们就不需要在一开始就渲染这些组件。 一个懒加载组件的简单实现 function isElementInViewport(el: Element) { const rect = el.getBoundingClientRect(); // 因为看板没有左右滚动所以不需要判断垂直坐标 return rect.top &lt; (window.innerHeight || document.documentElement.clientHeight) &amp;&amp; rect.bottom &gt; 0; } const RenderUntilInViewport: React.FC&lt;{ wrapper: React.ReactElement&lt;any&gt;; }&gt; = ({ wrapper, children }) =&gt; { const ref = React.useRef&lt;HTMLDivElement&gt;(null); const [display, setDisplay] = React.useState(false); React.useEffect(() =&gt; { function displayIfInViewport() { if (!display &amp;&amp; ref.current &amp;&amp; isElementInViewport(ref.current)) { setDisplay(true); return true; } return false; } if (displayIfInViewport()) { return; } window.addEventListener(&#39;scroll&#39;, displayIfInViewport, { capture: true }); return () =&gt; { window.removeEventListener(&#39;scroll&#39;, displayIfInViewport, { capture: true }); }; }, []); return React.cloneElement(wrapper, { ref }, display &amp;&amp; children); }; export default RenderUntilInViewport; 如果使用的是react-grid-layout的话，需要把初始动画关闭，不然组件的初始坐标都是(0, 0)，会使懒加载失效。关闭方法，不要使用useCSSTransforms={false}，这项会比较影响性能（测试看板+500ms的负收益）。 不过懒加载在测试看板的layout性能时带来的收益不大，大概能快100ms左右，或许用好折叠条组件（可以将一些组件折叠，默认不会去渲染）的话也没必要做吧。 组件延迟渲染（optional）同样在看板初始化阶段，这段时间里有很大一部分处于react-sizeme计算宽高然后触发组件更新所致，如果将组件真正渲染放到布局完成的话可能可以减少几次组件更新的消耗。 我们修改一下上面的懒加载组件，将第13行代码放到requestIdleCallback里。 // ...codes window.requestIdleCallback(() =&gt; { setDisplay(true); }, { timeout: 1000 }); // ...codes 可以看到看板布局的时间1300ms+ -&gt; 800ms+，虽然看起来提升了很多，但是看板真正展现信息还是要等组件渲染完，所以看板直到可用的等待时间相比原来可能还会增加。因此这节的优化点看实际情况去做吧。 结语虽然上面写了一大堆，但是基本不需要改多少代码就使页面变得不卡了。 看一下线上的前后对比，同样是上面的测试看板。 优化前 优化后(滚动页面加载完所有组件) 这里空闲时间比较多是因为请求完成的时间差导致","tags":[{"name":"react","slug":"react","permalink":"https://frezc.github.io/tags/react/"},{"name":"react-grid-layout","slug":"react-grid-layout","permalink":"https://frezc.github.io/tags/react-grid-layout/"},{"name":"dashboard","slug":"dashboard","permalink":"https://frezc.github.io/tags/dashboard/"},{"name":"frontend","slug":"frontend","permalink":"https://frezc.github.io/tags/frontend/"}]},{"title":"《Touhou Luna Nights》—— 令人惊喜的东方同人游戏","date":"2019-04-09T15:13:55.000Z","path":"2019/04/09/touhou-luna-nights-review/","text":"最近感觉和人说话的次数少了很多，总觉得这样下去不行啊，表达能力日渐衰退，有话不说憋着也难受。想了想多写写文章也许能发泄一下，就建了这个REVIEW目录。平时玩完游戏、看完动画、看完书之类的，如果有什么X后感的话就会写一下吧。 这次就讲讲清明放假期间玩通的这款《Touhou Luna Nights（东方月神夜）》，这个中文译名总觉得很中二呢。 总体评价这款游戏我认为是中等偏上的一款独立游戏，就算不了解东方也是值得花时间玩一下的。对于东方爱好者来说应该是近几年最值得玩的同人游戏之一了。 关于同人游戏自从ZUN放开对steam的限制后，已经有部分东方的同人游戏上steam了，虽然上的大多完成度都挺高的，但是和优秀的独立游戏还是有明显差距的。以前我也很喜欢东方的同人游戏，比如高中时很喜欢的《幻想乡之谜》，后来随着独立游戏的崛起，出现了很多非常优秀的独立游戏（比如minecraft、以撒的结合、splunky等等）后，我发现很多同人游戏除去IP加成，本身完成度是非常低的。 在steam上看到本作时，低像素风格但是很精致的画面让人眼前一亮，看了下标签 类银河战士恶魔城，刚打通空洞骑士，对这类游戏还是无法抵抗的。那时候还没正式发售，所以到现在才玩，不过extra stage还没做完，看了下出场人物，猜boss可能是⑨吧。 优点先讲讲画面，游戏里的人物是偏像素风，这么做可能是为了画不同动作简单一点吧，里面各个角色的动作还是挺丰富的，相比空洞骑士就多很多。场景虽然想说是像素风，但是更像是在低像素下画的素材，然后拉伸了而已。不过这种低像素的图加多层卷轴背景让我回想起了《MapleStory》，刚好戳中我喜欢的点。弹幕和飞刀特效也做得很炫酷。 另外游戏的一大亮点就是以时间停止为主的战斗和解谜了，时停在很多横板动作游戏里都有，但能让人用得这么频繁的基本没有吧。游戏因为时停使得战斗变得简单粗暴，初期玩起来还算是挺爽的。 从原作衍生的擦弹系统做得也很不错，这个系统算是隐藏特性（没有在教程中写明）。相比大部分原作（除了地灵殿和赶猪传）单纯分数相关的收益，本作里通过擦弹可以回血回魔对于大部分玩家都是很有用的。每个BOSS一般都会设计一个比较弱的阶段，本作里的BOSS也会有一个比较好擦弹的攻击方式，让玩家可以擦弹回血之类的，可以说是非常友好了。基本上掌握了这点，这个游戏就没有一个难的BOSS，对手残也是非常友好的。 不足整个游戏除了第一个场景和所有BOSS战外都挺。。“单调”的。 关卡设计只有断桥那处给我留下的映像，其他地方无论是场景还是解谜都一般般吧。整个地图只是简单的分叉式，这个对于后期重来时很不友好，因为只为了原来一个拿不到的物品跑一大段往返是很无聊的，当然这和传送门太少也有关，“近路”对于这类游戏还是很重要的。 时停这系统导致战斗就是一个套路走到底了，基本就是时停-技能，敌人的攻击方式都不知道就带走了。这样玩到后期就太无趣了，不过游戏的时间很短，这个问题倒不是很严重。 整个游戏花了5个小时玩通，只算我喜欢的BOSS战可能还不到50%的时间，对于62的定价显得不太值了。","tags":[{"name":"东方","slug":"东方","permalink":"https://frezc.github.io/tags/东方/"},{"name":"同人游戏","slug":"同人游戏","permalink":"https://frezc.github.io/tags/同人游戏/"},{"name":"独立游戏","slug":"独立游戏","permalink":"https://frezc.github.io/tags/独立游戏/"},{"name":"Touhou Luna Nights","slug":"Touhou-Luna-Nights","permalink":"https://frezc.github.io/tags/Touhou-Luna-Nights/"}]},{"title":"大阪游记","date":"2019-03-30T15:02:10.000Z","path":"2019/03/30/osaka-travel/","text":"这个月中旬去和同事去大阪玩了几天，趁着这个月还没结束写个游记吧，内容应该会比较流水账。 事前规划很重要这次虽然也是自由行但是比年初去东京的那次体验好得多吧，上次虽然有一大目的是参加CM，但是除此之外还是有不少时间可以到处玩的，不过缺乏规划的我们也没去成多少地方，主要是因为没有目标就很难有动力到处跑。 这次去的时候发现google地图真是好用，里面保存地点的功能是规划神器啊，这里分享一下我们这次大阪行程的规划（当然里面有因为时间缘故很多没去的地方）。地点里还有个分享的功能，适合和小伙伴一起编辑和投票，这个功能和自己保存的地方不能互通，也是比较奇怪。 如果要去圣地巡礼的话，可以利用这个网站找到感兴趣的地点，它会直接给你google map的地点，然后保存到自己的列表里再做规划。 另外要注意景点的时间限制，日本的景点很多下午就关门了，要早去。 飞机、酒店和电话卡这次虽然是自由行，机酒还是通过旅行社购买的（公司规定），可能会比单买贵一点吧，不过会方便一些。这次坐的厦航和全日空比，除了没有座位前的小平板外其实没什么差距，体验还不错。酒店住的是HOTEL MYSTAYS Otemae，算是名宿？相比之前秋叶原住的酒店便宜很多，房间也大很多（感觉有2倍大），除了没有每日打扫和厕所有点味外和住一般酒店差不多吧，但是实惠很多。 前次去东京玩一个很大的问题就是定位总是会失效，这次换了一家买电话卡，结果是要好一些，除了在车站和地铁里外都能好好工作，不知道这方面WIFI是不是会好用一些。 第一天中午坐的飞机再坐电车到酒店都已经傍晚了，这次坐的是普通电车只要1000多一点，大阪这边也有类似东京的skyliner的haruka，需要额外买票，看了下haruka的到达时间没有快多少，价格却贵了不少。 到了大阪的车站就发现和东京很不同的一点，在东京的车站里是没有“出口”这个称呼的，写的都是“改札口”（检票口），而在大阪的车站里则是清一色的“出口”，可能是地方差异吧。还有一点是在车站地铁里大多是右侧通行，我印象中东京靠左的比较多。 晚上在道頓堀附近逛了一下，吃了一餐烤肉。 第二天第二天上午先去了日本桥附近，逛了下黑门市场、一些动漫游戏店和信长书店（我也不知道为什么要进去了）。中午吃了王将（饺子就一种，但是没有国内的油腻）后就去大阪城了。 大阪城公园还是挺大的，要说有什么特别的话就是乌鸦很多吧。 随处可见的乌鸦 大阪城作为很多电影游戏里的常客，实际看到比想象里的小一些。里面有很多层，基本都是讲相关历史，展出的一些重制的（也可能是原版）武士刀、火器、服装、屏风等挺有意思的。 之后去了梅田附近，逛了逛大阪站这里的pokemon center，买了些小东西；去附近的游戏厅玩了一会；坐了次hep five摩天轮，这个我到觉得白天坐比较好，晚上没什么好看的。晚餐是一风堂的拉面，听说这家是以比较辣的拉面出名的，不过当时没点那款，听小伙伴描述并不辣的样子。 第三天这天就是神户一日游，神户这里有很多fate里冬木市的取景地，所有算是一次圣地巡礼了。 上午先走了一遍神户大桥和附近的公园，很容易会想起fate里的一些名场景。 从旁边公园里拍的神户大桥 之后去了北野异人馆街，这里的看点就是比较欧式风格的建筑吧，不过对fate fans来说也是一大圣地，有好几处熟悉的取景地。下面是風見鶏の館，fate中远坂凛家的取景地。 風見鶏の館 桌子上有一些熟悉的纸人，后面藏着一个pipi美 中午去吃了神户牛（还是烤肉），似乎神户这里的牛肉店都是神户牛啊。 之后本来预想是去六甲山牧场的，但是到六甲山下已经3点多了，被告知牧场4点半就不让进了，坐铁轨上山+公交到牧场是来不及的，所以只能放弃去牧场了。 上山后大概4点多本想去下摩耶山掬星台，不过巴士司机告诉我们这是最后一班车，不能过去了，至于理由日语太烂了没问清。之后就只能去东面玩了。 在六甲山天览台俯视风景还是很棒的，能看到云朵就在很近的距离飘过，就是风太大了，这个季节还是有点冷。在一个甜品店坐到晚上看看夜景就回去了。 白天俯瞰风景 傍晚 晚餐吃了蟹道乐，个人最喜欢的是前菜的生蟹，比较像温州的江蟹生。 放毒 第四天第四天去的是京都一块。 京都这边寺庙很多，其中也有不少圣地，光看各种寺庙和神社都能走一天。这天先去看了伏见稻荷大社，这个神社的特点就是一排排鸟居了，上面都刻着捐赠者的名字，走在千本鸟居下爬了一圈山，风景不错但是一早就爬山真的很累。 千本鳥居 去拉面小路吃了一份黑富山酱油拉面后就坐公交到了清水寺，这次来得不巧，最有特色的建筑刚好在维修，从外面看着怪怪的。内部能看到很多含苞待放的樱花，晚来几天应该会非常好看。清水寺下来是一块很大的墓地，这边也没什么可看的，最好还是原路返回出去。 维修中的清水寺 随后去了花见小路附近，因为还是下午好像店都没开，不过街上人是真的多。 休息了一下就向宇治出发了，顺路刚好先去看了下京阿尼的两栋办公楼。其中一栋下面是个周边店，卖京都动画的各种周边，这里有卖叫“生動画”的东西，看起来是一些分镜原稿之类的东西。 京阿尼 随后电车坐到了宇治站，本来以为很看到京吹的一些人物牌子，好像被撤掉了。宇治这里的话就是京吹的主要取景地了，能看到这么多动画里的原场景还是很让人激动的。过了宇治桥，沿着宇治川往南走，发现这边虽然比较乡下但还是会有旅游团会来的，毕竟还是有“宇治抹茶”这个特产。我们来的这个季节倒也没什么游客（人也很少），又不巧的是宇治川的岸边被封住了，中间的小岛也在建什么东西的样子。 桥 宇治这里有4个附带名场景的桥，上面这个应该是最不知名的一个。沿着岸边走完了几个桥就去大吉山展望台了，算是京吹第8话的圣地巡礼吧。 路上会遇到宇治神社和宇治上神社，在神社里甚至还能看到京吹剧场版的宣传图。展望台这只有一个小亭子，如果没有京吹里那么甜的一幕，应该也不会有很多参观者吧。这边并不高，但是几乎能把整个宇治收入眼底，待这看了日落就下去了。这里山路没有灯，路上还有凸起来的树枝和石头，晚上还是有一点危险的。 大吉山展望台 宇治这里我还是挺喜欢的，人少很安静，路上也能看到一些和我们相同目的的人。之后要走的时候看到车站附近有一家回转寿司店，就顺路吃了晚餐。去日本玩的话回转寿司还是吃饭的好去处，好吃不贵，点餐也是自助的。 第五天最后一天就是收拾东西回家了，去机场坐的电车还有前半后半目的地不同的操作，这个google map上是不会告诉你的，需要注意一下。 总结最后做一遍技术总结，要想玩得开心，有以下要领： 提前规划，和小伙伴讨论行程 量力而为，太累会影响后面情绪 兴趣使然，如果要去圣地巡游，那么有顺路的名景点就去吧，不然就不要强迫自己去了","tags":[{"name":"旅游","slug":"旅游","permalink":"https://frezc.github.io/tags/旅游/"}]},{"title":"react hooks踩坑记录","date":"2019-03-23T03:02:14.000Z","path":"2019/03/23/react-hooks-traps/","text":"自从 react@16.8 正式发布react hooks已经有一段时间了，这段时间我也一直在项目里使用hook的方式来写组件，其间也遇到了不少问题，下面列一下踩坑记录。 该篇假设你已经了解react hooks的基本用法，如果对react hooks毫不了解，建议先阅读官方文档。 想在第一次render前执行的代码，可以放在useState里类似class component里的constructor和componentWillMount。例如 const instance = useRef(null); useState(() =&gt; { instance.current = &#39;initial value&#39;; }); useState里数据务必为immutable虽然class component的state也提倡使用immutable数据，但不是强制的，因为只要调用了setState就会触发更新。但是使用useState时，如果在更新函数里传入同一个对象将无法触发更新。 举个例子，有时可能会写出这种代码 const [list, setList] = useState([2,32,1,534,44]); return ( &lt;&gt; &lt;ol&gt; {list.map(v =&gt; &lt;li key={v}&gt;{v}&lt;/li&gt;)} &lt;/ol&gt; &lt;button onClick={() =&gt; { // bad 这样无法触发更新 setList(list.sort((a, b) =&gt; a - b)); // good 必须传入一个新的对象 setList(list.slice().sort((a, b) =&gt; a - b)); }} &gt;sort&lt;/button&gt; &lt;/&gt; ) useMemo has no semantic guarantee这句话出自useMemo的API Reference。 You may rely on useMemo as a performance optimization, not as a semantic guarantee. In the future, React may choose to “forget” some previously memoized values and recalculate them on next render, e.g. to free memory for offscreen components. Write your code so that it still works without useMemo — and then add it to optimize performance. 也就是说在未来react的版本，useMemo在必要时会清除缓存而重新执行creater function，所以最好不要使用useMemo来执行具有side effect的函数。 举个例子，比如我想实现基于lodash throttle的hook，使用useMemo来实现会比较理想，类似下面的代码 const thRef = useRef(null); useMemo(() =&gt; { if (thRef.current) { thRef.current.cancel(); } thRef.current = _.throttle(fn, wait, options); }, [wait, options &amp;&amp; options.leading, options &amp;&amp;options.trailing]); // ...other codes 目前这么写是没问题，但是考虑到未来react实现了上述“forget”特性的话，这样的代码就可能产生预料之外的结果，解决方法就是自己实现一个稳定的useMemo，实现示例。 useEffect和useLayoutEffect有什么区别？简单来说就是调用时机不同，useLayoutEffect和原来componentDidMount&amp;componentDidUpdate一致，在react完成DOM更新后马上同步调用的代码，会阻塞页面渲染。而useEffect是会在整个页面渲染完才会调用的代码。 官方建议优先使用useEffect However, we recommend starting with useEffect first and only trying useLayoutEffect if that causes a problem. 在实际使用时如果想避免页面抖动（在useEffect里修改DOM很有可能出现）的话，可以把需要操作DOM的代码放在useLayoutEffect里。 不过useLayoutEffect在服务端渲染时会出现一个warning，要消除的话得用useEffect代替或者推迟渲染时机。见说明和讨论。 在useEffect和useLayoutEffect里使用async函数因为async函数肯定会返回一个Promise，会和useEffect返回的cleanup函数混淆所以不要直接将async function传给useEffect，最简单的解决方法是IIFE。 useEffect(() =&gt; { (async () =&gt; { await fetchSomething(); })(); }, []); 使用useCallback时，要注意闭包问题（或者说是Capture Value特性）和避免使用inline function一样，有时需要使用useCallback来优化性能，但是useCallback会返回之前的闭包，使用到的局部变量是不会更新的。举个例子 const [count, setCount] = useState(0); const increaseCount = useCallback(() =&gt; { setCount(count + 1); }, []); // 因为useCallback总是返回第一次render时传入的闭包，increaseCount内访问到的count永远都是0 increaseCount(); // 相当于setCount(1); increaseCount(); // 无论调用几次都是setCount(1); 解决方法就是避免引用外部的局部变量 const [count, setCount] = useState(0); const vRef = useRef(0); const increaseCount = useCallback(() =&gt; { // 传入function的话每次都能拿到最新值 setCount(prevCount =&gt; prevCount + 1); // 用一个对象来保存，适用于不需要触发更新的情况 vRef.current += 1; }, []); // 使用useReducer解决 const [count, increase] = useReducer((c, increment) =&gt; c + increment, 0); const increaseCount = useCallback(() =&gt; { increase(1); }, []); 但是注意不要这么写。 关于Capture Value可以参考这篇文章。 useEffect、useCallback、useMemo等API的第二个参数数组的长度不能变有时可能会写出这样的代码 const [selectedStatuses, setSelected] = useState([]); useEffect(() =&gt; { fetchListById(selectedStatuses); }, selectedStatuses); 这里如果将selectedStatuses从[]更新为[&#39;active&#39;]是不会触发effect的，react也会给你一个warning。相关源码。 这里最好将整个state作为deps的一项传入，或者使用一个key来控制 useEffect(() =&gt; { fetchListById(selectedStatuses); }, [selectedStatuses]); 泛型参数怎么写？通常我们会这么写函数组件 const MyCom: React.FC&lt;MyComProps&gt; = (props) =&gt; { return &lt;div&gt;...&lt;/div&gt; }; 但是在参数里使用了泛型，就不能这么写了，因为在变量声明里必须要指定确切的类型，所以这里要回到传统function的写法。放心，这么写也是有类型提示的。 // generic props interface MyComProps&lt;T&gt; { value?: T; onChange?(value: T): void; } function MyCom&lt;T extends { type: string; }&gt;(props: MyComProps&lt;T&gt;) { return &lt;div&gt;{props.value &amp;&amp; props.value.type}&lt;/div&gt;; } 不过如果要用React.forwardRef的话目前没什么什么优雅的方案，还是需要明确类型才行。 使用React.memo和React.forwardRef包装的组件为什么提示我children类型不对？过去使用Component、FC等类型定义组件时一般不需要我们定义props里children的类型，因为在上述类型里已经帮你默认加上了 { children?: ReactNode } 的定义。但是@types/react的维护者认为这样导致children几乎没有类型约束，组件开发者应该显式地声明children类型。所以对新的API应该都不会自动加上children的定义了，需要开发者手动添加。 详情见讨论。 使用act给react hooks写单元测试react@16.8给test-utils新加了一个 act API，关于这个API可以看看作者写的这篇通俗易懂的解释。 这里简单总结一下act主要是为了解决useEffect的测试问题出现的，因为useEffect的执行时机会很晚，甚至在断言之后。如果在useEffect里执行了ui变更，就很难写测试了，虽然可以用useLayoutEffect解决，但是不能为了通过测试而修改原代码。这里用act就能很好地解决了，这个API能同步执行所有useEffect以及相应的更新，在断言时就能拿到正确的结果了。 before use act 总之所有可能触发更新的代码都应该放到act里，不然test-utils会给一个warning。 另外act会batchUpdate，可能会导致一个隐藏bug，见文章中这段内容，需要注意一下。 Function Component与ant design的FormForm非常适合使用react hooks来实现，官方目前看来没什么进展，不过目前hoc也没什么问题。 用FC写的自定义表单控件会有ref相关的warning，因为antd form需要拿到组件的ref，而FC默认是没有实例的。这里我们可以通过React.forwardRef + useImperativeHandle解决，官方示例。不过这么写validateFieldsAndScroll这个API可能就没用了，建议把ref传给底层的表单元素组件。 我收集了一些常用的hooks，欢迎使用和一起开发。https://frezc.github.io/react-hooks-common/ References useEffect vs useLayoutEffect react官方文档 https://github.com/threepointone/react-act-examples/blob/master/sync.md https://github.com/facebook/react https://github.com/DefinitelyTyped/DefinitelyTyped/pull/33602 https://ant-design.gitee.io/components/form-cn/#components-form-demo-customized-form-controls https://juejin.im/post/5c9827745188250ff85afe50","tags":[{"name":"react","slug":"react","permalink":"https://frezc.github.io/tags/react/"},{"name":"react-hooks","slug":"react-hooks","permalink":"https://frezc.github.io/tags/react-hooks/"},{"name":"test","slug":"test","permalink":"https://frezc.github.io/tags/test/"},{"name":"ant-design","slug":"ant-design","permalink":"https://frezc.github.io/tags/ant-design/"}]},{"title":"使用typescript实现依赖注入框架","date":"2018-08-17T05:58:15.000Z","path":"2018/08/17/how-to-impletement-denpendency-injection-in-typescript/","text":"首先思考一个问题：我们为什么需要依赖注入(Dependency injection下面简称DI)？ 之前用java的spring、php的laravel和angular时发现它们的模式非常相似，框架会把请求处理、线程管理、错误处理等都封装好，你只需要实现对应的横向和纵向切面，然后让框架来管理和调用你的代码，这就是设计模式中有名的控制反转(简称IOC)。 而DI是IOC的一种比较通用的实现方式，举个例子我们的web服务中有controller（接口层）和service（业务逻辑层），我们需要在controller中调用service的代码，但是service一般会有上下文(context)（比如使用了当前的请求对象、数据库连接、全局参数等）。如果我们每次在调用service时都要手动给它这么多参数实在太麻烦了，而且代码会很耦合。此时DI就能解决这个问题了，我们只需要声明需要的对象，框架就能自动创建好带有上下文对象。那么下面我们来看看怎么用ts实现一个简单的依赖注入框架。 下文写的时候我还没有使用过nodejs写过复杂的后端服务，所以造了个简单的轮子来梳理项目代码，使用的hapijs社区也不太活跃，所以本文仅适合作为参考和学习使用。要使用nodejs开发大型应用的话建议使用nest.js或者eggjs。 核心API先看看实现的API长什么样 import * as Knex from &#39;knex&#39;; import { autowired, impl, context } from &#39;../injection&#39;; class MyController { @autowired userRepository: IUserRepository; getUsers() { return this.userRepository.getAllExistUsers(); } } // 这里用抽象类来表示接口（下面会通称为“接口”） abstract class IUserRepository { abstract getAllExistUsers(): PromiseLike&lt;IUser[]&gt;; } @impl(IUserRepository) class UserRepositoryImpl extends IUserRepository { @context(&#39;knex&#39;) knex: Knex; getAllExistUsers() { return this.knex(&#39;users&#39;).select().where(&#39;deleted&#39;, false); } } 这里的API设计稍微参考了下spring，还有一些妥协设计（比如为什么要用abstract class而不用interface、为什么 @impl 需要传入对应接口），这些下面会解释。 API实现原理这里虽然实现了3个decorator，但是这些decorator的作用其实和java里的annotation一样 —— 定义metadata，所以实现上很简单，基本上都是一句话就能讲清楚里面的逻辑： @autowired (需要自动注入的变量)：把当前的property key（&#39;userRepository&#39;）以及对应的type（IUserRepository）存到当前类的metadata中，方便后面注入的时候传入。 @impl (实现某个接口的类)：将当前的接口和类保存到一个全局Map&lt;接口, 实现&gt;。 @context（需要注入当前应用上下文的变量）：将当前key（&#39;knex&#39;）与需要注入的context key（&#39;knex&#39;）保存到当前类的metadata 下面是autowired的实现 export const metaKey = Symbol(&#39;autowiredKeys&#39;); interface IAutowiredKey { // 字段名 key: string; // 对应类型，通过metadata返回的类型必定是Object与其子类 type: Function; } export default function autowired(target: any, propertyKey: string) { const autowiredKeys = getAutowiredKeys(target); // 得到当前装饰成员变量的类型 const type = Reflect.getMetadata(&#39;design:type&#39;, target, propertyKey); autowiredKeys.push({ key: propertyKey, type }); // 将变量保存到当前类的metadata里 Reflect.defineMetadata(metaKey, autowiredKeys, target); } /** * 拿到在当前类上定义的需要自动注入的key和type */ export function getAutowiredKeys(target: any): IAutowiredKey[] { return Reflect.getMetadata(metaKey, target) || []; } Typescript metadatatypescript可以通过metadata拿到3种类型信息 对象上的成员变量类型 函数的参数类型 函数的返回类型 但是又有非常大的限制，可以看一下这一节文章，简单来说就是拿不到 interface 的类型，而 abstract class 可以，所以使用中需要用 abstract class 来代替 interface 。 另外关于 @impl 为什么要传入对应接口，主要是因为如果不传入接口的话，在注入@autowired变量时，我必须要遍历被@impl装饰的类来判断其是否是该变量类型的本身或者子类。 这里可能会出现一个问题，如果@autowired的变量类型是interface啥的话，由于上面提到的限制我只能拿到 Object 这个类型，由于所有类都是其子类，所以就会注入错误的类型了。 注入关于@autowired字段的注入实现非常简单，实现以下几步就行了： 拿到对象需要注入的字段及其类型 根据类型判断并创建需要注入的对象 递归注入上一步生成的对象，并注入上下文 将生成的对象传给成员变量 const implMap: Map&lt;any, any&gt; = new Map(); export default function impl&lt;T, C extends T&gt;(p1: T) { return function (ctor: C) { implMap.set(p1, ctor); } } export function injectAutowired(target: any, context: { [key: string]: any }) { const needAutowiredKeys = getAutowiredKeys(target); needAutowiredKeys.forEach(({ key, type }: { key: string, type: any }) =&gt; { const ctor = implMap.get(type); let inst = null; if (ctor &amp;&amp; typeof ctor === &#39;function&#39;) { inst = new ctor(context); } else { // type must be Object inst = new type(context); } injectAutowired(inst, context); injectContext(inst, context); target[key] = inst; }); } 路由设计路由层参考laravel框架，因为我个人认为将路由放在一个地方同一管理比spring那种分散到Controller上定义要方便索引（api -&gt; controller）。 提供的API如下 import { Route } from &#39;../injection&#39;; const route = new Route(); // 设置放置controllers的目录，默认是 ${work directory}/controllers route.setControllersRoot(&#39;server/controllers&#39;); // 指定Controller的method作为handler route.post(&#39;/apples/{id}&#39;, &#39;SampleController@updateApple&#39;); route.get(&#39;/users&#39;, &#39;SampleController@getUsers&#39;); // 直接传入函数作为hanlder route.match([&#39;get&#39;, &#39;post&#39;], &#39;/healthz&#39;, () =&gt; &#39;ok&#39;); // prefix route.prefix(&#39;admin&#39;).group((r) =&gt; { r.post(&#39;users/{id}/ban&#39;, &#39;AdminController@banUser&#39;); }) export default route; 这里除了将 Controller 引入并绑定到对应的 path 上外，还要检测对应的方法是否存在，这样就能将错误放在程序启动时而不是运行时抛出了。 接口层的IO目前设计的API如下 // controller内 class MyController { getUsers(@param id: number, @query detail: boolean = false, @payload body: Object) { return { users: [] }; } getUser(@query(&#39;name&#39;) userName: string, request: Hapi.Request, h: Hapi.ResponseToolkit) { return { users: [] }; } } // 直接传入路由的函数 route.get(&#39;welcome/{name}&#39;, (name: string) =&gt; { return { name, message: `welcome ${name}` } }); 这里有3个decorator，分别代表 路径参数（@param）、查询参数（@query）、和请求体（@payload），作用同样是设置metadata。另外有一些框架特定类型的参数（Hapi.Request和Hapi.ResponseToolkit），是为了支持更加特殊的需求。 对于直接传入路由的函数，我对其的定位是“不需要复杂输入的简单逻辑”，所以只会把路径参数的指根据顺序传进去。 注入数据时需要考虑参数类型，我这里定了几个规则： 如果类型是 string、number、boolean，那么需要将数据转为对应的基础类型 如果类型是一些特定类型，比如Hapi.Request，那么由对应框架的bind来判断注入 如果类型是 Object（可能是object、interface等），那么将数据原样返回 如果类型是 Function（class），分为以下的情况 先new对应的类，如果注入的数据不是基础类型，并且对应的class的构建函数没有参数，那么将注入数据Object.assign给新建对象 如果对应的class的构建函数有参数，或注入的数据是基础类型，那么将注入数据传入class的构建函数 返回类型和异常处理都是目前是由Hapi.js自己处理的，还没研究过express这些库的处理方式，不过应当遵循下面的规则： 返回类型应当支持所有能JSON序列化的值和Promise。 抛出异常应当可以直接throw，并有一个统一处理方法 项目结构因为对于依赖注入的API来说controllers、services和repositories都是一样的，所以项目结构其实可以由自己的项目情况决定，不过建议分为以下几个层面： controllers: 负责接口IO处理，表单验证，流程控制 services: 负责业务模块逻辑 repositories: DAO层，负责与数据库打交道 models: 数据模型 routes.ts: 定义路由 app.ts: 项目的启动、配置 绑定Hapi.js目前在项目里用到的service端实现是hapi.js，所以讲讲injection与hapi.js的bind需要实现的功能： 根据路由配置生成hapi的路由配置 在handler里注入所有的接口依赖、上下文依赖以及方法的参数依赖 import { injectAutowired, injectContext, callHanlderWithInjection } from &#39;../injection&#39;; // 生成Hapi route handler的函数 function createControllerHandler&lt;T extends IClassType&gt;(Controller: T, methodName: string, context: { [key: string]: any }) { return (request: Hapi.Request, h: Hapi.ResponseToolkit, err?: Error): Hapi.Lifecycle.ReturnValue =&gt; { // 将请求对象绑定到当前上下文 const contextInLifecycle = Object.assign({ request }, context); const c: any = new Controller(contextInLifecycle); injectAutowired(c, contextInLifecycle); injectContext(c, contextInLifecycle); return c[methodName](request, h, err); }; } Todo 路由层的权限控制 更加通用的参数验证 更加通用的错误处理 更加通用的Request与Resposne结构 DAO层使用ORM 实现Laravel里的Facades模式？ 利用typescript的compiler解决上面的局限问题","tags":[{"name":"typescript","slug":"typescript","permalink":"https://frezc.github.io/tags/typescript/"},{"name":"web service","slug":"web-service","permalink":"https://frezc.github.io/tags/web-service/"}]},{"title":"Grafana的auto decimal实现以及与G2结合使用","date":"2018-08-02T07:25:03.000Z","path":"2018/08/02/auto-decimal-of-grafana/","text":"Why auto decimals?现在即席查询里的单位格式化用的是从grafana里copy出来的kbn，kbn里的format函数的参数除了value外通常还有decimals和scaledDecimals。 decimals指的是传统意义上的保留小数位，如1.23对应的就是2。 scaledDecimals指的则是单位转换过后的保留小数位，比如kbn转换时间时会默认将超过1000的时间进位，1234ms -&gt; 1.23s，这里1.23就是scaledDecimals = -1时的结果（单位转换时会增加decimals，这里从ms -&gt; s就增加了3位decimals）。 decimals和scaledDecimals的使用规则是，如果没有scaledDecimals统一使用decimals，有的话在发生单位转换时使用scaledDecimals，其他情况使用decimals。 下面要讲的auto decimals就是用来计算这两个值的。 grafana的auto decimals算法这里主要讲的是graph panel下的auto decimals，graph下tick的decimals和tooltip稍有不同，后者的decimals多一位，scaledDecimals多两位 主要实现代码在 grafana\\public\\app\\core\\utils\\ticks.ts 文件的 getFlotTickDecimals(datamin, datamax, axis, height) 函数。 export function getFlotTickDecimals(datamin, datamax, axis, height) { const { min, max } = getFlotRange(axis.min, axis.max, datamin, datamax); const noTicks = 0.3 * Math.sqrt(height); const delta = (max - min) / noTicks; const dec = -Math.floor(Math.log(delta) / Math.LN10); const magn = Math.pow(10, -dec); // norm is between 1.0 and 10.0 const norm = delta / magn; let size; if (norm &lt; 1.5) { size = 1; } else if (norm &lt; 3) { size = 2; // special case for 2.5, requires an extra decimal if (norm &gt; 2.25) { size = 2.5; } } else if (norm &lt; 7.5) { size = 5; } else { size = 10; } size *= magn; const tickDecimals = Math.max(0, -Math.floor(Math.log(delta) / Math.LN10) + 1); // grafana addition const scaledDecimals = tickDecimals - Math.floor(Math.log(size) / Math.LN10); return { tickDecimals, scaledDecimals }; } 从这个函数的第二行可以发现grafana是通过图表的height来动态计算y轴的tick count，然后得到 delta = tick interval 来进行接下来的运算。 计算decimals比较简单，在代码的27行，基本上就是求以10为底的delta的对数，并且对于超过10的数字decimals都为0，所以在grafana里要显示比较大数字的小数，如10.012，就必须要手动设置decimals。 计算scaledDecimals的方法比较奇怪，首先算出了delta的位数的最小值 magn （例：9999 -&gt; 1000，424 -&gt; 100），然后算出了在1~10内的标准值 norm （例：9999 -&gt; 9.999，424 -&gt; 4.24）。接下来是一堆 if else 组成的分段函数根据 norm 求得 size * magn，最后用decimals减以10为底的size对数得到scaledDecimals。这个计算方法奇怪之处是根据 norm 求 size 的部分，因为这块size小于10是完全不会影响结果的，不知道为什么要分开这么多段。（可能是代码写错或者我没考虑到一些特殊情况） 这种算法在一般情况下还是很适合的，比如下面3张图，第一张的interval = 25k，算得的scaledDecimals刚好抵消了单位转换带来的额外小数；第二张的interval = 10000，算得的scaledDecimals刚好是-4，而单位转换的额外decimals是6（0 -&gt; k -&gt; Mil，每次进位多3位小数），所以保留了2位小数；第三张没有转换所以用的是由interval = 0.1得到的decimals = 1。 接入即席查询肯定不能简单地将grafana里的代码copy过来直接用，因为G2计算ticks interval的算法和grafana里不一样，在尽量少修改的基础上想了2个方案 因为G2可以自定tick count和interval，或许可以考虑直接用grafana的利用高度计算ticks count的算法？我觉得grafana计算tick count的算法还是挺不错的，不过使用场景有限：只能用于直角坐标系、只能用于连续型数据、每次高度变化都要去更新scale的format函数（会导致G2重新处理数据，性能上可能会有问题）。 拿到G2计算好的ticks然后传给计算auto decimals的函数。这里麻烦的是拿到G2计算的ticks，虽然可以通过处理好数据的G2对象拿到ticks，但是这样意味着每次都要渲染两次，不太合理。所以还是要主动调用相关的api来 计算，因为G2没有暴露相关的api，所以会用一些比较hack的方式去调用。 需要的计算ticks的函数在 @antv\\scale\\src\\auto\\number.js 里，这个函数看起来参数比较多，其实只要传入min、max就可以计算了，但是为了兼容之后可能会添加的列定义表单，还是找更为上层的封装更合适。于是利用位于 g2\\src\\chart\\controller\\scale.js 的 ScaleController ，这个类只需要传入转换后的Scale，并调用其 createScale 方法来得到所需结果。","tags":[{"name":"grafana","slug":"grafana","permalink":"https://frezc.github.io/tags/grafana/"},{"name":"g2","slug":"g2","permalink":"https://frezc.github.io/tags/g2/"},{"name":"visualization","slug":"visualization","permalink":"https://frezc.github.io/tags/visualization/"}]},{"title":"如何修复错误的merge提交","date":"2018-04-30T15:39:49.000Z","path":"2018/04/30/how-to-fix-wrong-merge/","text":"因为最近帮别人解决了一次git merge丢代码的情况，当时处理地简单粗暴，reset到merge前一次commit后重来一遍。后来又设想了一下，如果merge后又commit很多次，这样岂不会很麻烦？如果这个分支不允许force push，那这样做也不行。于是就去查了一些资料，自己尝试并总结了一下几个方法。 用git reset重新来过这种方法很简单，就是git reset到merge之前的一次commit，然后重新merge，然后如果之前在merge之后还有commit的话利用git cherry-pick &lt;commit start&gt;^...&lt;commit end&gt;apply到当前分支。最后git push --force到远端分支（如果之前已经push了的话） 这种方法适合你在push之前就发现了错误的情况，因为用了git reset后当前分支就必须要force push了。 force push有什么问题？一般来说不应该在非私人分支上force push，因为这有可能会覆盖掉其他人在该分支上的commit。而且远端的protected branch是不能直接force push的。 更好的方法？首先解决第一个问题，如何不用force push？ 如果我们不修改要push分支的历史的话是不需要force push的，那么很简单了，只要把需要修改历史的reset操作在另外一个不需要push的分支上操作就行了。 实际操作就是从当前分支拉一条新分支出来，然后进行上面reset的方法，最后再rebase或merge回当前分支。 既然这里也提到了rebase，其实我们还可以简化一下上面的方法。 # 假设我们这里merge feature到master # 使用第一种方法 git checkout -b fix-merge git reset &lt;commit before merge&gt; --hard git merge feature # fix conflict git cherry-pick &lt;commit start&gt;^...&lt;commit end&gt; # maybe need fix conflict git checkout master git merge fix-merge # fix conflict # 用rebase简化一下，因为rebase也是一个会修改历史的操作，所以还是需要新开分支 git checkout -b fix-merge # 用rebase代替了reset &gt; merge &gt; cherry-pick的操作 git rebase -i &lt;commit before merge&gt; # fix conflict git checkout master git merge fix-merge # fix conflict 这里在rebase时添加了-i的参数，可以清楚地展示和操作每次会应用的commit。如果不懂rebase可以看看官方文档。 用上面的方法要处理的冲突太多了怎么办？无论是cherry-pick还是rebase都是将commit一次次给apply，所以merge之后的commit如果有冲突，那也得一次次解决，有时候一直要改同一个文件的话，那解决冲突就是很痛苦的一件事了。 这里有两个方案可以考虑一下： 其实在第一种方法中完全没必要用cherry-pick，新分支在重新merge后可以直接merge到当前分支的。当然这样还是一样要处理很多冲突，只不过可以一次处理完了。 git checkout -b fix-merge git reset &lt;commit before merge&gt; --hard git merge feature # fix conflict git checkout master git merge fix-merge # fix large conflict 如果是丢了代码并知道丢的是哪次提交的代码，那么可以直接git cherry-pick &lt;commit id&gt;。 直接改代码。 git revert可以解决问题吗？我在网上也看到很多用git revert来解决错误merge的方法，但是这样做只能撤销merge而无法去修复merge，而且就算提交了revert commit，当前分支也不能重新merge，因为revert只是普通的commit而不能改变已经存在的merge commit。","tags":[{"name":"git","slug":"git","permalink":"https://frezc.github.io/tags/git/"}]},{"title":"恢复更新","date":"2017-12-16T11:18:38.000Z","path":"2017/12/16/这个博客不会再更新了/","text":"本来打算就用issue写文章了，但是写了一点后发现github上还是太严肃了，不太好瞎扯些非技术性地东西，所以还是换回hexo写了。。 这次花了点时间把typecho上的文章都迁了，有点心思想把动漫排行捡起来，不过匹配关联这块要自动化确实不太好做，手工的话一个人没什么精力。","tags":[]},{"title":"webpack和webpack-dev-server的配置备忘","date":"2016-08-06T14:17:00.000Z","path":"2016/08/06/webpack和webpack-dev-server的配置备忘/","text":"自从上次用webpack写web应用感觉已经过了一段时间了，这次重新拾起又花了不少时间。 为了下次能更快地使用webpack开发，决定写篇文章把配置的问题记录下来。 webpack基本配置 devtool: 在开发中可以使用&#39;eval&#39;(打包速度快)、&#39;inline-source-map&#39;(打包速度慢，但在浏览器里能直接查看编译前的代码)等值；生成环境中不要设置或设为false entry: 结构可以是 entry: { app: APP_DIR + &#39;/app.js&#39;, vendor: APP_DIR + &#39;/scripts/vendor.js&#39;, login: [ APP_DIR + &#39;/login.js&#39; ] } output: 注意下publicPath，要设置为打包后资源的url路径 module: 注意下scss的loaders的写法 // 开发中 loaders: [&#39;style&#39;, &#39;css&#39;, &#39;postcss&#39;, &#39;sass&#39;] // 生成环境 导出到一个css文件 loader: ExtractTextPlugin.extract(&#39;style&#39;, [&#39;css&#39;, &#39;postcss&#39;, &#39;sass&#39;]) resolve: 可以用extensions来指定import时可以省略的后缀名；可以用alias指定从非npm引入的库，如jquery: path.resolve(__dirname, &#39;./bower_components/jquery/dist/jquery.js&#39;)，这样在import时可以替换引用路径 externals: 指定从全局引入的库，如jquery: &quot;jQuery&quot;，这样在require(&#39;jquery&#39;)时会引入jQuery对象 常用插件 ProvidePlugin: 定义一些在import时能自动引入的变量，如定义了$: &#39;jquery&#39;后，可以在文件中直接使用$，webpack可以自动帮你加上var $ = require(&#39;jquery&#39;) CommonsChunkPlugin: 将多个entry里的公共模块提取出来放到一个文件里，这个插件可以用来将库和自己代码分离 DllPlugin: 将一些模块预编译，类似windows里的dll，可以在项目中直接使用，无需再构建。注意要在output中指定library，并在DllPlugin中指定与其一致的name，在有多个入口时可以使用[name]和[hash]来区分，因为这个参数是要赋值到global上的，所以这里使用[hash]不容易出现变量名冲突的情况 DllReferencePlugin: 引用之前打包好的dll文件，注意下context参数，这个应该根据manifest.json文件中的引用情况来赋值，如果引用的都是npm安装的库，这里就填项目根目录就好了 NoErrorsPlugin: 在打包时不会因为错误而中断 DefinePlugin: 可以定义编译时的全局变量，有很多库（React, Vue等）会根据NODE_ENV这个变量来判断当前环境。为了尽可能减少包大小，在生产环境中要定义其为JSON.stringify(&quot;production&quot;) optimize.UglifyJsPlugin: 配置压缩代码，如 compress: { unused: true, dead_code: true, warnings: false } optimize.OccurrenceOrderPlugin: 可以减少文件大小 optimize.DedupePlugin: 可以减少重复文件数 ExtractTextPlugin: 可以将所有css文件打包到一个css文件中，配置见loader webpack-dev-server和react-hot-loader的相关配置如果只进行客户端开发，不适用nodejs渲染的话，推荐安装webpack-dev-server CLI，可以省去很多配置。 首先看看cli里常用的几项配置： –port=8080：这项指定了服务器端口，相当于在entry中加上webpack-dev-server/client?http://0.0.0.0:8080，前者是后者的简便用法，注意这两个不要重复。 –hot：开启热替换功能。如果要使用react-hot-loader，这项是必须要开启的；如果只是想在更新代码后自动刷新页面，则不需要。这项等同于在plugins中添加new webpack.HotModuleReplacementPlugin()，同样注意不要重复。 –inline：这个的功能是为了能在你自己的测试服务器上获取的html页面中获取webpack-dev-server动态生成的js文件，基本上如果要用webpack-dev-server这个是必要的。详情说明见文档。这个参数会在entry里加上webpack/hot/dev-server，注意不要重复了。 虽然加了这项就能变更后自动刷新页面了，但是要用hmr还有几点要注意： output.publicPath一定要使用完整的url，如&quot;http://localhost:8080/dist/&quot;，端口要和wds相同，不然会出现跨域的错误提醒。 在html页面中当然也要以完整的url来引入。 如果要写同构应用的话，使用webpack-hot-middleware并按照文档的写法就可以了。","tags":[{"name":"webpack","slug":"webpack","permalink":"https://frezc.github.io/tags/webpack/"},{"name":"webpack-dev-server","slug":"webpack-dev-server","permalink":"https://frezc.github.io/tags/webpack-dev-server/"}]},{"title":"给RN的app添加widgets","date":"2016-06-25T18:12:00.000Z","path":"2016/06/26/给RN的app添加widgets/","text":"widgets应该是android平台上最有用的特性之一了吧，将应用的数据利用一个小视图嵌入其他应用（如桌面），可以快速地获得app的状态而不用启动app。 最近用react-native写了一个todo app，感觉将计划利用widgets直接在桌面上展现出来会十分的方便，于是就给这个app加了widgets。当然rn没有给我们提供这方面的支持，毕竟是android端的东西，只能直接写原生了。虽然很久没写过原生android了，但是看看文档还是没有问题的。 appwidgets基础首先可以看看官方文档吧，虽然它里面讲的东西在Android studio上点击New-&gt;Widget-&gt;App widget就能帮你生成好，不过看看文档了解下配置参数和AppWidgetProvider的原理还是不错的。 由于我这里要用到ListView，还是要按照文档的内容进行一下修改，主要就下面的5个文件（还要在AndroidManifest.xml注册接收者和服务）： TodoWidget: AppWidgetProvider的子类，用来生成和更新根view。 TodoWidgetService: 用来生成ListView中每项视图的服务 todo_widget.xml: 每项视图的layout文件 todos_widget.xml: 根视图的layout文件 todo_widget_info.xml: 配置文件 这些按照文档里的写就可以了，不过有点需要注意的是如果你选了最小宽度为4格，minWidth会给你填上250dp，实际在android上运行的时候这个widget的最小宽度是3格。我去github上看到一个开源app里appwidiget的配置文件里看到4格写的是294dp，试了下这个数值没什么问题就直接用了。 appwidgets里得到app的数据appwidgets里使用的数据最好是持久化的，如果你想让widgets自动更新的话（widgets默认会有一个更新周期）。RN里提供了持久化api-AsyncStorage，那么原生app中怎么从中得到数据呢？ 看看AsyncStorage的源码里的这条语句 // Use RocksDB if available, then SQLite, then file storage. var RCTAsyncStorage = RCTAsyncRocksDBStorage || RCTAsyncSQLiteStorage || RCTAsyncFileStorage; 可见一般情况下在android平台上是通过SQLite进行存取的。另外在源码的/ReactAndroid/src/main/java/com/facebook/react/modules/storage/ReactDatabaseSupplier.java中我们可以得到数据库名、表名和表中每列的名称。实际上AsyncStorage只是将k-v值直接保存在一张表里而已。那么从数据库中读取数据应该是很简单了，只要在每次更新时进行读取就行了，也就是在RemoteViewsFactory的onCreate和onDataSetChanged中读取。（ps：你当然可以通过网络请求来获取数据，rn使用了okhttp+fresco，你可以在app中直接使用这两个库） 由于我们在rn中保存时一般是转成json字符串的，所以读取后还需要解析成对象才能使用，这里用一个你会熟悉的解析库就行了。（RN自带了一个jackson-core库，不过这个用起来不是那么方便，你可以再引入jackson-databind就会好用很多了） 另外有一点要注意的是，app在没有保存任何东西的情况下，AsyncStorage对应的表是不会创建的，这时候直接读取这张表肯定会报错。解决方案：捕获一下异常即可 private String queryFromDB(SQLiteDatabase db, String key) { // try-with-resource need min-api 19 Cursor c = null; try { c = db.rawQuery(&quot;select * from &quot; + TABLE_CATALYST + &quot; where &quot; + KEY_COLUMN + &quot; = ?&quot;, new String[]{key}); if (c.getCount() &gt; 0) { c.moveToFirst(); String result = c.getString(c.getColumnIndex(VALUE_COLUMN)); c.close(); return result; } } catch (SQLiteException ignored) { } finally { if (c != null) c.close(); } return &quot;&quot;; } app响应点击事件设置点击事件的PendingIntent就按照文档的写法就可以了，如果要在rn中得到点击传递的参数的话，还要写一个原生模块来获取当前Activity的Intent对象并去除数据。 这个部分可以参考react-native-system-notification这个开源库里的写法，不过在点击时app是不会再前台运行的（目前来说是这样的），所以点击后只要startActivity并在Intent中带上FLAG_ACTIVITY_CLEAR_TOP这个flag就行了。然后在rn中通过原生模块获得Intent中带的数据。 具体完成的样子就是这样了 点击后的跳转 [8.1更新] 关于RemoteViews的一个BUG ?之前发现在appwidgets里如果description没有数据会显示&quot;No description.&quot;，第一次滚动下来时会显示正确的结果，不过重新滚回去再滚下来显示就会出现异常。 Debug半天发现取得和生成的字符串没问题后，仔细观察了下异常数据，发现异常的数据似乎是前面项遗留的数据。我之前只是简单地判断了下有description时更新到视图中，于是我再加了条在没有description把显示值设置为&quot;No description.&quot;，发现就没问题了。看起来是由于RemoteViews重用而导致的BUG，还真是个坑啊。","tags":[{"name":"android","slug":"android","permalink":"https://frezc.github.io/tags/android/"},{"name":"react native","slug":"react-native","permalink":"https://frezc.github.io/tags/react-native/"},{"name":"widgets","slug":"widgets","permalink":"https://frezc.github.io/tags/widgets/"}]},{"title":"React的渲染性能优化","date":"2016-04-24T17:20:00.000Z","path":"2016/04/25/React的渲染性能优化/","text":"都说网页的性能瓶颈在DOM操作，所以目前的主流前端框架（React、 Vue、AngularJs等）都在极力地减少DOM操作。 就React而言，使用Virtual DOM和一个diff算法（实际就是使用一个uid来判断）来尽可能的重用现有的DOM，以此来减少DOM操作（毕竟添加比更新要耗时）。 但是在一些需要高帧数刷新的组件里，即使是Virtual DOM的re-render也会显得十分耗时，那么我们看看怎么进行优化。 渲染速度问题比如需要实现这么一个列表 &lt;div&gt; &lt;Indicator percent={this.state.percent} /&gt; { this.state.items.map(item =&gt; &lt;Item item={item} /&gt; ) } &lt;/div&gt; 这个组件我们需要监听scroll事件，在处理函数里更新state中的percent属性。默认React不会进行任何优化处理，就这么写的话会发现在滚动页面时会有卡顿感，我用自己项目的一个列表项测试了一下（RepoAbList.js），打印了scroll开始、结束和render开始的时间，如下。 下面是滚动时不进行render的情况 可以发现正常情况scroll回调的间隔是16、17ms，如果render的时间超过这个值就会影响到scroll的刷新率。虽然react更新dom是异步进行的，但是对Virtual DOM的渲染时同步的。所以这里scroll也得等render结束才能继续。 那么就必须去优化一下Virtual DOM的渲染速度了。这里我们可以打印一下列表项中的每个Item的render时间，就能发现虽然每项都只用了1、2毫秒来渲染，但是加起来就不少了。 shouldComponentUpdateReact也有给出解决方案，shouldComponentUpdate在默认情况下是返回true的，也就是说只要props或state改变，这个组件就会更新，同样子组件由于props的改变也会更新，具体情况可以参考这里。 由于列表的Virtual DOM在每次render时都是重新生成的，所以就不要指望vDOMEq相同了，最简单的方法就是实现每个Item的shouldComponentUpdate方法（通过比较当前和传入的props来判断是否需要更新，由于属性为object需要判断内部的变化，或许我们需要immutable-js）。 PureRenderMixinReact提供的PureRenderMixin其实已经帮我们做好了上面需要做的事，按文档中的做法就行了。不过这个插件会比较所有的属性，在某些情况下可能会和预期相违。比如传入一个函数的情况，可以看看我提的一个Issue。 官方要保持这个插件的单一性，所以要忽略函数的话需要我们自己实现一下。我们可以使用Shallow Compare这个插件来十分简便地完成，只要筛选掉原来props对象中的类型为&#39;function&#39;属性，再调用Shallow Compare就可以了。","tags":[{"name":"react","slug":"react","permalink":"https://frezc.github.io/tags/react/"},{"name":"performance","slug":"performance","permalink":"https://frezc.github.io/tags/performance/"}]},{"title":"谈谈4月新番","date":"2016-04-17T17:39:00.000Z","path":"2016/04/18/谈谈4月新番/","text":"跳过了整个1月番后，感觉上都已经好久没追番了。说实话近期的新番实在不对我胃口，于是空闲时把逆转无赖开司和混沌武士给补了。 不过这次的4月番看起来还是不错了，总之又有动力去追了，到目前为止看了一些比较感兴趣的，其中倒是有几部十分有潜力呢。下面就稍微谈谈 迷家冈妈的大名使得大家对这部番的走向想的出奇地一致啊，从前两集看来结局或许是那么回事。 这部番的第一个显而易见的特点就是角色多，为了展现每个人的特点特地花了半集来做自我介绍。在12话的时间内要写出这么多角色的特点还是十分困难的，如果写不出特点那就和普通的路人无二了。不过从前两集来看人物描写的还是十分有趣的，希望别没说出自己的故事就莫名其妙的挂了啊。 JOJO第四部JOJO第三部说实话并没有期望中的那么好看，有几段让我印象深刻（赌徒达比、伊奇那几段），但是最后和屌爷大战时过程就没那么精彩了。这次的不灭钻石当然还是很期待的。 逆转裁判原作游戏本就没有什么引人入胜的剧情，更多的是找证物在法庭上反驳证人的乐趣，看到动画这么还原，只能是fans向了吧。 当女孩遇到熊女主好萌。日常。日常。看第二集还是有点意思的。属于那种可看可不看的番吧。 从零开始的异世界生活听说小说挺受欢迎的，不看轻小说的我看了第一集也被吸引了。这部番可以说是这季除了甲铁城外的最大黑马了吧。看了两集后，发现有漫画就补掉了。至少就漫画的内容来说确实是十分有趣的。 抛去回溯时间这种东西，这番的亮点不就是男主了吗，说实话男主的表现是最让我想看的，除了这点当然还有挺有特色的角色（比如帕克）。 Joker Game目前只看了一集，看起来是写二战谍战的，不过主角不是间谍啊（自己这么说的），所以要表达什么不是很清楚。这种番还是看完再发表意见比较好。 双星之阴阳师前两集看了没什么特点（除了那些挺好看的过场画面），没什么特点是指都能猜到接下来要干什么了。不过听说漫画很有趣，好了不多说了，我先去找个能看这个漫画的app了。 文豪野犬这番对于不了解剧中出场的日本文豪来说会挺无聊吧（除了妹子），只认识太宰治的我看到那个叫太宰治的帅哥喊出[人间失格]来发动和当妈一样能力的时候还真是一口老血啊。我觉得我还是再去看一遍人间失格也比这番好吧。 线上游戏的老婆不可能是女生（简称 老婆不可能是女生）游戏中同工会的好友在现实中都是萌妹子，在现实中我肯定是不信的。虽然是传统的套路，看了前两集还是稍微想看下去的。 甲铁城的卡巴内瑞制作阵容还是十分豪华的，巨人的制作公司wit studio，鲁鲁修的剧本大河内一楼（最近几作是没什么可说的），还有只生产XX神曲的泽野弘之。还没放就已经万众瞩目了吧。第一集的质量是意料之中的高，不过有大河在后面还真不敢保证，不过就前半相信是十分精彩的。ps: 此作中的萝莉好萌，prpr。 坂本ですが漫画很好看，动画做的也很不错，但是这么火还是挺奇怪的。 飞翔的魔女又是一部日常系的吧。第一集看下来真的很平淡，不像女孩遇到熊那样还有些笑点。 其他女高有个外传来着，不过语速太慢也没什么笑点。还有些泡面就不说了。","tags":[{"name":"anime","slug":"anime","permalink":"https://frezc.github.io/tags/anime/"}]},{"title":"React的服务端渲染","date":"2016-04-16T17:19:00.000Z","path":"2016/04/17/React的服务端渲染/","text":"最近在使用React来做一个收藏夹类似的网站，同时也是为了学习一下前端技术，于是就尽可能的使用了流行的框架。 项目链接这个项目中使用了React + Redux + React-router + babel + webpack + scss，来构建了一个同构应用。虽然同构应用并不是十分必要的，不过为了尝试下新技术还是尽可能地去用了。 后端由于一开始就考虑用Laravel了（那时候还不知道有同构应用这东西），而且直接丢给同学做了，所以并没有做到完全地同构，仅仅只是在渲染页面上同用一套代码。（由于不是用NodeJs，也就没使用GraphQL+Relay了）。 在什么地方使用服务端渲染能带的好处就是对搜索引擎友好，所以对于一般的SPA是不必要的。所以在资源页面（用户信息页面、资源列表页面、资源详情页面等）上做好服务端渲染就行了。在一些编辑页面上就没什么必要了。 Redux如果要使用React来做服务端渲染，我觉得像Redux这样的库是有必要的。Redux使用单一的状态树，传回初始状态时会十分方便，将下面的标签放到你的脚本标签前就行了。 &lt;script&gt; window.__INITIAL_STATE__ = ${JSON.stringify(initialState)} &lt;/script&gt; 当然这里不要忘了过滤标签，我这里使用的方法是 [Server] let initState = JSON.stringify(store.getState()); // 使用encodeURIComponent过滤掉特殊字符 let page = renderFullPage(initView, encodeURIComponent(initState)); // 别忘了引号 &lt;script&gt;window.__INITIAL_STATE__ = &quot;${initState}&quot;&lt;/script&gt; [Client] const initState = window.__INITIAL_STATE__; const store = configureStore(JSON.parse(decodeURIComponent(initState))); 服务端渲染时的生命周期忘了在哪看到服务端渲染时不会执行React组件的生命周期方法了，实际上componentWillMount这个方法还是会执行的，所以在这个方法内还要注意下执行环境。 配合React-Router和共用Action Creator可以使用React-Router提供的match来匹配路由表，然后通过回调函数得到路由信息，在路由信息中我们是可以得到对应的组件的，所以我们可以把调用的对应Action Creator（用过API获取数据）放到这个组件的一个静态方法里直接调用，这样我们就可以对所有路由一视同仁了。 相信大多数人会把网络请求放到Action Creator中来写，那么我们就可能懒得再去对服务器端写API请求了，而是直接dispatch这个Action Creator。作为同构代码这个Action Creator就需要注意下运行环境了，首先当然是使用isomorphic-fetch这个库，当然你可以自己判断当前环境来使用浏览器或node上的fetch。 服务器端的同步请求我这里的同步指的是服务端等待API请求结束后再返回页面。在客户端只要在请求结束后进行异步地更新状态就好了，在服务端得等待这次请求（可能会有多个请求）完全结束才行。很多人会想到回调函数，不过给Action Creator加个回调函数的参数显得不太美观，而且似乎不能处理多个请求的情况。这里既然已经使用了fetch，那么干脆就使用es6中的Promise来处理。 1、首先在需要预渲染数据的页面里实现一个相同名称的静态方法来调用Action Creator。 // server fetch static fetchData = (params) =&gt; { // 注意要返回 return fetchUserNetwork(params.id) }; 2、然后在这个Action Creator中调用Api，同样要注意返回fetch返回的Promise export function fetchUserNetwork(id) { return (dispatch) =&gt; { // 这里调用的相当于 fetch(url) return Api.userInfo(id) .then(response =&gt; { if (response.ok) { // 结果中有其他耗时处理的Promise同样要返回 return response.json().then(json =&gt; { dispatch(fetchUserSuccess(json)); // 让服务端能判断是否请求成功 return response.status; }); } else { return response.status; } }) .catch(error =&gt; { return &#39;error&#39;; }); } } 3、在服务端我们将所有的Promise使用Promise.all方法放到一个Promise中 function fetchComponentsData(dispatch, components, params) { let fetchData = components.reduce((pre, cur) =&gt; { return Object.keys(cur).reduce((acc, key) =&gt; { return cur[key].hasOwnProperty(&#39;fetchData&#39;) ? acc.concat(cur[key].fetchData) : acc; }, pre) }, []); const promises = fetchData.map(fetch =&gt; dispatch(fetch(params))); return Promise.all(promises); } 4、最后我们在这个Promise的then和catch中将组件渲染啊成string再返回就可以了。 返回不同的状态码如果需要在返回页面时返回相应的状态码的话，只要像上面在fetch().then里return response.status。然后就能通过Promise.all创建的Promise的then中得到一个状态码的数组了。 fetchComponentsData(store.dispatch, renderProps.components, renderProps.params) .then(status =&gt; { console.log(&#39;statu&#39;, status[0]) } 其他判断当前环境的函数 export const isBrowser = new Function(&quot;try { return this === window; } catch(e) { return false; }&quot;); export const isNode = new Function(&quot;try { return this === global; } catch(e) { return false; }&quot;);","tags":[{"name":"react","slug":"react","permalink":"https://frezc.github.io/tags/react/"},{"name":"server render","slug":"server-render","permalink":"https://frezc.github.io/tags/server-render/"}]},{"title":"标准化React + Redux = 纯函数式编程？","date":"2016-03-05T18:35:00.000Z","path":"2016/03/06/标准化React-Redux-纯函数式编程？/","text":"最近看到github上一个Airbnb公司的js风格指导手册，感觉里面讲的都挺有道理的，里面的风格都是趋向使用es6来取代之前的各个api。其中有关React有一条提到了在没有state和ref时，推荐使用单纯的绘制函数代替类，看到后翻了下官方文档，发现propTypes和defaultProps还是能用的。 想起之前用的Redux框架，其核心不就是将所有组件无状态化吗，配合它岂不是就能做到完全的函数式编程？于是马上去改写了下之前写的小例子。 改写需要做的也就是把类中的所有函数拿出来，将render名字改为类名，传入参数props，删掉this，将其他函数的参数进行相应的修改，最后别忘了export default XXX;。AnimeDayList.js –改写前 AnimeDayList.js –改写后 由于基于flux思想进行的设计，所有组件都可以改为纯函数。由于在根组件App里定义了componentWillMount生命周期方法，所以就没改了，当然根组件作为有状态组件在flux思想里也是完全合理的。 整个例子的6个组件只定义了一个类，其他全部都是纯函数，使得整个项目清爽了很多啊。","tags":[{"name":"react","slug":"react","permalink":"https://frezc.github.io/tags/react/"},{"name":"redux","slug":"redux","permalink":"https://frezc.github.io/tags/redux/"},{"name":"fp","slug":"fp","permalink":"https://frezc.github.io/tags/fp/"}]},{"title":"开始使用Redux","date":"2016-03-01T17:29:00.000Z","path":"2016/03/02/开始使用Redux/","text":"最近开始试着用React来写前端了，虽然感觉在构建Web上React实在是有些大材小用，但是毕竟这个库的可是打着Learn Once, Write Anywhere的口号来着，在写不同平台应用时会用React写得开心就行。 然后我发现了Redux这个东西，这是flux的一个实现，那么flux是什么玩意呢？很明显flux不是什么实际的框架，而是一种框架思想，特点就是单项数据流吧，它是将所有状态更新都放到一个数据流中进行处理。相比MVC，Flux弱化了Controller的功能吧。 下面讲讲具体的例子。(请确保你对React已经十分熟悉) 官方的todoApp是十分简单明了的演示了，第一次照着例子打一遍可以有一个大致的理解。 首先看一下应用的一个流程图 这是应用内部数据流的演示，实际上Redux已经帮我们把数据流相关的函数封装好了，所以剩下的需要我们写的也就action creator和reducer了。我写了一个starter，可以直接拿来修改开发。 View我个人习惯还是从View开始开发，View部分和原本的React开发并没有什么不同。只要注意一点，不要在组件中使用state，所有需要控制的地方都使用属性，之后你需要从父组件将属性传入。页面我使用全文本表示了，并没有加多少css。 Store因为没有在组件里使用state，所以状态怎么保存呢？Redux里将所有状态都放到了一棵状态树里，而这个状态树保存在Store实例里。那么在View如何获得这个状态树呢。 这里做了3件事，绑定中间件、创建store、通过Provider组件绑定View和store。这么做以后store里的状态树更新时都会传递给View。然后在你需要获得状态树的组件里（官方建议只在顶层组件里获取） 通过connect绑定该View后，每次状态树更新时都会调用select函数，参数就是状态树，该函数的返回对象会传递给该View的props对象 这样之前根据之前写的通过属性控制的View就会自动更新了。 Action &amp; Action CreatorAction指的是更新状态的请求，其格式一般（不是一定）是这样的 {type: DOWHAT, params: optional} type是提醒Redux要做什么，Action中也能跟其他参数。当然你可以自己定义格式，只要在后面Reducer里处理时对应就好。 Action Creator就是返回Action对象的纯函数，其存在的意义主要是少打代码、减少错误。 有了Action后只要调用dispatch方法（见上上图）就能通知Redux要干什么了，接下来Action会传递给Reducer处理，以更新状态树。 PS: 如果需要请求API的话只要不写在Reducer里就可以了，dispatch action纯粹只是用来更新状态的，和之前setState功能相同。所以只要请求完后异步dispatch一下就可以了。不一定要使用redux-thunk之类的异步库。 ReducerReducer有点类似于MVC中Controller的功能，其作用就是通过用户传来的Action更新状态树。Reducer都是纯函数，所以这里需要注意下函数式编程（fundamental pattern）的思想。怎么写见官方文档。 写Reducer做好3点就可以了 按照状态树的结构拆分，根Reducer最好调用combineReducers 所有Reducer函数里的state必须要有初始值，在es6中很简单，直接在参数中赋值就行了，像其他编程语言一样。 为了符合fp的思想，不要在reducer中修改传入的state。如果要修改则应该返回一个全新的state。 总的来说reducer怎么写取决于状态树的设计，所以建议在写reducer前把状态树设计好，再对应状态树写函数。 总结虽然一开始搭建一个Redux的结构比普通项目要麻烦很多。但是之后再进行修改时就会发现项目结构十分的清晰，比起MVC中将管理状态、组件更新、网络请求等全部塞到Controller里，Redux把这些功能都分散到了Reducer、Store、Action Creator里，就显的很整洁了。 说实话理解Redux还是花了不少时间的，尤其是要解决“这比起MVC有什么优势吗”这个疑问。我这里还是推荐官方文档(中文版)。","tags":[{"name":"react","slug":"react","permalink":"https://frezc.github.io/tags/react/"},{"name":"redux","slug":"redux","permalink":"https://frezc.github.io/tags/redux/"}]},{"title":"react-native对md风格中StatusBar的处理方式","date":"2016-02-20T20:09:00.000Z","path":"2016/02/21/react-native对md风格中StatusBar的处理方式/","text":"自从rn支持android以后，出现了不少的material design的库。用了下一个叫react-native-material-design的库，先不谈性能方面的缺陷，这个库完全忽视了StatusBar的处理，使得其Drawer弹出时会很难看。至少目前还没有看到哪个库对StatusBar进行了特殊处理，官方倒是有一个StatusBar的组件可以用来控制应用中StatusBar的表现，不过这个组件在android里是调用5.0加入api来实现的，也就是说只对5.0以上的系统有效。而且这个组件在实现Drawer占满屏幕的效果时，StatusBar要设为translucent，此时和在theme中设置windowTranslucentStatus没有什么区别，依然要考虑StatusBar空出来的地方。所以这个组件还不如设置theme呢，起码后者能兼容到4.4。 下面就谈谈比较合适的方法。 拿b站的app来看看要实现的效果。 RN中的实现这个效果基本上都是设置translucent后，在Statusbar的位置画一个相同大小的View来实现的。rn里虽然没有现成的库，但是实现起来也是非常简单的。 首先在android项目里的控制app theme的style项里添加 &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt; 然后在Navigator上添加View 这里的style为`javascriptstatusbar: { backgroundColor: COLOR.googleBlue700.color, // Statusbar的颜色 height: 24 // Statusbar的高度，android上为24dp} 实现的效果 这样做还是有些不足的，比如Statusbar在未来的android版本中出现变动的话就得修改代码了，当然为了避免这点我们可以写个原生模块动态获取Statusbar的高度。 还有个办法就是在原生的android的项目中自定义View，不过这种方法麻烦而且扩展性不好，就不去实现了。","tags":[{"name":"android","slug":"android","permalink":"https://frezc.github.io/tags/android/"},{"name":"react native","slug":"react-native","permalink":"https://frezc.github.io/tags/react-native/"}]},{"title":"在Android的原生模块中得到RN组件的引用","date":"2016-02-19T15:23:00.000Z","path":"2016/02/19/在Android的原生模块中得到RN组件的引用/","text":"最近学习了下使用react-native(以下简称rn)来做App，这是目前唯一一个编写跨平台的本地应用的开源库，所以人气也是非常高啊。因为是新东西，所以相关的讨论、开源库之类的都很少，目前有很多东西还是得依赖原生模块来处理。好在的是rn提供了一些挺简单的交互方法，所以不至于会有无法解决的严重后果。 不过在调用原生模块时，一开始我不太清楚怎么去获得rn里组件的实例引用，在网上也没找到相关问题，后来在看源代码后发现该怎么做了。 分析一开始我是想看看DrawerLayoutAndroid组件是如何实现调用openDrawer和closeDrawer方法的，发现它是通过UIManager这个模块来分发命令，然后去看了下这个模块的源代码，发现了创建、删除、查找View等方法的装饰方法，具体是用UIImplementation这个类实现的。于是找到UIImplementation中的createView方法 可见这个方法并没有创建真正的本地组件，之后通过NativeViewHierarchyOptimizer（优化UI层次）和UIViewOperationQueue（渲染的缓冲队列）两个类的处理后调用了NativeViewHierarchyManager的createView方法。 上图是这个方法中创建本地组件的关键语句。这里有三行注释，主要讲的就是把react的tag存到组件的id中，这样更容易复用组件。调用setId将tag保存到组件的属性当中。这里我们就发现了原生组件的id其实就是对于rn组件的tag。那么最后一个问题就是怎么获得tag呢？ 在DrawerLayoutAndroid.android.js文件中我们找到closeDrawer方法，它调用了UIManager的dispatchViewManagerCommand方法，这个方法是讲指令传递给目标组件管理器调用的（下篇博客会讲），在源码中就能知道第一个传入参数其实就是rn组件的tag。那么如何获取就和_getDrawerLayoutHandle方法写的一样了。 实现自己实现原生模块时需要找到rn组件实例的话只要相应的传入tag，然后调用findViewById即可。 这里我偷了个懒，直接把MainActivity的实例暴露了出来，最好的方法还是利用消息传递给Activity处理。（更正：最好的方法应该是注册Package时传入activity实例，然后在createNativeModules方法中将activity传给module对象。）这里要注意的是，模块的方法是异步执行的，如果你要更新ui的话，要切到主线程执行。 上面的代码还是存在挺严重的bug的，第二次调用setText就会时程序fc，目前还不清楚原因。目前来说并不推荐利用这样的方法来更新rn的组件。","tags":[{"name":"android","slug":"android","permalink":"https://frezc.github.io/tags/android/"},{"name":"react native","slug":"react-native","permalink":"https://frezc.github.io/tags/react-native/"}]},{"title":"用SVG画一个笑脸男图标","date":"2015-12-30T16:23:00.000Z","path":"2015/12/31/用SVG画一个笑脸男图标/","text":"自从看完攻壳的第一季后就想自己做个会动的笑脸男的矢量图图标了，最近花了点时间终于搞定了。下面我会谈谈网页上矢量图该怎么写。预览（在ie和edge上文字无法滚动，在chrome上是正常的，其他浏览器不清楚）。源代码。 制作矢量图的工具虽然在网页上是用代码实现的，但是设计还是需要一个能画矢量图的工具的。可以用Illustrator(Ai)或者一个在线的工具就可以了。我这里直接用了别人用ai设计的矢量图，所以对详情设计也不太了解。 然后使用一个越方便越好的画svg的js库就行了。原本看网上大家都推荐使用raphael.js，但是这个库没有画路径文字的方法，于是果断找了另外一个库svg.js，这个库能解决这个问题，还比raphael.js要小。 用代码画矢量图笑脸男的图像里基本上都是使用路径画好的，所以只要使用画路径的方法就行了。关于路径，w3有一套规范，只要能看懂这里的写法就好，这是所有库都通用的标准写法。其中可能让人困惑的一点就是arc画法了（其实规范里的图已经说明的挺好了）。它是提供当前点（起始点）、x、y上的半径、旋转角度、large-arc-flag、sweep-flag和终点来确定一个弧的。其中large-arc-flag指是否画大一点的弧，sweep-flag指从起点到终点是否为顺时针画线。 对路径熟悉后就可以把你设计图给搬进代码里了，如果你的编辑器能直接生成w3标准的代码的话就再好不过了。 转动的文字文字的部分其实有点麻烦，麻烦在做动画上。 var t1 = paper.text(s); t1.fill(&#39;#23498C&#39;).font({size: 50, &#39;letter-spacing&#39;: 2.3, weight: 700}) t1.path(&#39;M 605,365 A 300,300 0 1,1 605,260&#39;) 先将路径确定好，并调整文字的一些属性，使其和原图一样。 t1.textPath().attr(&#39;startOffset&#39;, &#39;0&#39;).animate({ ease: &#39;-&#39;, duration: 10000}).attr(&#39;startOffset&#39;, &#39;100%&#39;).loop() 然后调用动画方法就能动了。但是这样无法将文字循环，文字播放到终点就消失了。一开始我想再用一个文字矢量图接着这个画的，但是svg里的startOffset不能使用负值（负值当然也是有效的，但是不能像0~100%这样设置）。于是想用逆时针路径然后倒过来播放，可惜这样文字就倒过来了，也不知道是否有办法设置。 最后终于想到一个完美的方案 t1.path(&#39;M 605,365 A 300,300 0 1,1 605,260 M 605,365 A 300,300 0 1,1 605,260&#39;) t1.textPath().attr(&#39;startOffset&#39;, &#39;0&#39;).animate({ ease: &#39;-&#39;, duration: 10000}).attr(&#39;startOffset&#39;, &#39;50%&#39;).loop() 把路径画两遍，然后播放时startOffset从0~50%进行循环就行了。如果你也想实现这种无限循环地旋转的话，可以试试这个方法。 其他之所以做这个还是由于对笑脸男这个人物的喜爱吧，有能力的同时愿意来为真相做出贡献。有意思的是，攻壳第二季第二集的主人公和他完全就是相反的人。空想但没有勇气去做，想想自己和大概也就是这样的人了。","tags":[{"name":"动漫","slug":"动漫","permalink":"https://frezc.github.io/tags/动漫/"}]},{"title":"动画的排行榜 - 页面实现","date":"2015-12-25T04:18:00.000Z","path":"2015/12/25/动画的排行榜-页面实现/","text":"离上篇文章都已经一个多月了啊，最近都在玩mho，也没什么时间来做这个。不过目前还是把基本的功能都给实现了，做了一个展示页面。 和以前说的一样，后端是使用Laravel框架实现的api服务器，前端是用vue.js和semantic-ui实现的页面。点此访问 后端Laravel也不是第一次用了，还是挺熟悉的，不过也碰到过一些问题，这里记录一下。 数据库配置：api返回错误信息The Response content must be a string or object implementing __toString()时，首先还是要检查一下数据库的配置是否正确。我这里将动漫排行的数据放在了一个独立的数据库中管理，所以要在laravel里额外配置不同的数据库连接，这里会十分容易出错。 跨域请求：使用ajax请求不同域名的api时需要注意下跨域请求的问题，为了能进行跨域请求，返回的header里需要有Access-Control-Allow-Origin这一项来确定允许跨域请求的域名。我这里为了方便，让所有api能让所有域名访问（方便本地测试），直接修改nginx的配置文件，在location中添加一条add_header Access-Control-Allow-Origin *;就ok了。 前端前端的css库使用了某人推荐的semantic-ui，我也没用过bootstrap，所以用什么都无所谓，不过semantic比起bootstrap的资料真是少。然后是vue.js，数据的双向绑定和定义组件都是非常好用的，我没有用过其他类似的库，所以也不好比较。 虽然没有必要，但还是试着用了webpack管理项目，这个库简单来说就是将一堆js和css文件打包的一个js文件中，在发布时你的页面中只要引用一个打包后的js文件就行了，对于非常复杂的单页应用来说，这是个能减少项目复杂度的工具。 然后讲讲问题 渲染速度：原本我想把1000多项数据直接展示的，不过渲染速度还是有限，vue.js渲染1000项的列表也得要接近2秒的时间，于是想想还是分页了。 提示框：在页面中使用了semantic的提示框组件，不过使用的时候仅仅在html中添加data-title和data-content并没有什么用，还要调用这些节点的popup()函数。但是节点都是通过vue.js之后动态生成的，那要怎么在渲染完成后调用呢？这里可以使用vue.js提供的自定义指令实现，注册一个指令，在bind接口中调用就ok了。 其他本来想借用下Bangumi的图片的，不过没法跨域请求，那就没办法了，之后有空就去爬取一遍吧。 剩下还有个留言评论的模块，没时间就用多说来做了。 PS: 最近一直在玩mho 华东一 隐士之森 id: 心悦会员 欢迎找我玩PS2: steam也开始打折了，不过启示录2怎么就第一章打折啊，卡表还是坑。","tags":[{"name":"动漫","slug":"动漫","permalink":"https://frezc.github.io/tags/动漫/"},{"name":"anime","slug":"anime","permalink":"https://frezc.github.io/tags/anime/"},{"name":"rank","slug":"rank","permalink":"https://frezc.github.io/tags/rank/"},{"name":"排行","slug":"排行","permalink":"https://frezc.github.io/tags/排行/"}]},{"title":"做个动画排行榜 - 标题匹配","date":"2015-11-22T13:07:00.000Z","path":"2015/11/22/做个动画排行榜 - 标题匹配/","text":"上次写了篇做排行的文章，然后做到现在，匹配不同网站的信息还是一大难点啊，做到现在，剩下的数据还是手工去处理会准确且快一些。 这次在将Ann与Sati信息匹配时使用了与Bgm和Sati匹配时不同的方法。 Ann的信息匹配这次匹配的核心是ratio，jaro和jaro_winkler这3个字符串相似度算法，利用这些算法很明显可以解决之前存在的标题中有单个字符不匹配的情况。这次使用的一些规则。这里原先Ann的日期获取缺失了很多，后来看了几个页面后才发现是日期会有不同的结构，重新爬取了一遍（代码），顺便做了次筛选，分辨出评价人数过少的番剧。这次爬取后，日期基本就完整了，使用了日期比对后匹配率一下子就上来了，最后只剩85项未匹配。这些就直接手工解决了。 最后一个问题就是有些番剧在一个网站上是合并的，而在其他两个网站上是分开的。这里我原本是直接留下第一季的信息，但是后来发现还挺多的，还是将多个url用逗号隔开保存了，到时候取分时直接计算多个url的平均分了。 网站计划网站我目前的想法是，后端api服务器Laravel，前端Semantic UI + Vue.js。不过目前时间太少，这个计划会挺慢的。 其他因为python没有和c那样的for循环，所以在项目中一直使用while循环进行迭代，这次加了个continue，发现就出bug了。于是又找了下资料，才知道python中写索引迭代要这么写 for i in range(start, end): your code 相当于 for(i=start; i &lt; end; i++){ your code }","tags":[{"name":"anime","slug":"anime","permalink":"https://frezc.github.io/tags/anime/"},{"name":"rank","slug":"rank","permalink":"https://frezc.github.io/tags/rank/"}]},{"title":"做一个多网站的动画排行榜吧","date":"2015-11-19T15:55:00.000Z","path":"2015/11/19/做一个多网站的动画排行榜吧/","text":"起源是以前看过的一个B站视频。视频里统计了中国的Bangumi,日本的Sati和欧美的Ann的评分，并取三者平均分进行排名。 总的来说，这个排名还是挺靠谱的，所以我也想做一个这样的排名，利用网页的形式展示并能够定时地更新。 利用爬虫抓信息经某人推荐用了Scrapy这个库来写爬虫。首先很简单通过每个网站的列表可以得到动画名和url, 由于ann上默认是英文名，所以必须去爬取每个动画的详情页来获得日文名，sati和bgm上都是能直接得到日文名的，所以并没有去爬取详情页。这些存入数据库后就开始下一步 统一信息这是最麻烦的一步了，因为各个站点的命名并不统一，就算你使用了很多的规则去匹配也不可能做到100%准确的，还是需要人工检查。虽然如此，当然能用程序匹配得越多越好了。 匹配当然需要通过原日文名，于是我观察了一下sati和bgm上的日文命名区别，写了一些规则： “ミス・モノクローム -The Animation-“ 在SATI中没有 ‘-‘ 符号 ‘!’ 在SATI上是 ‘！’, 在ann和bgm上不确定 bgm可能会比sati多个副标题 如 ‘攻殻機動隊ARISE’系列 标题间的空格可能会不相同 sati会在剧场版动画名前加上 ‘劇場版’ , 而bgm不会 sati可能会在标题尾加上括号并有补充内容 当然这些并不是很全，实际在匹配时用了精确到模糊的查找。 将原标题中的’劇場版’和前后空格去掉，将一些全角符号替换成半角的 精确查找，考虑到有括号补充内容的问题，也同样将括号去掉的内容和括号内的内容进行精确的查找 考虑到标题中的特殊字符存在或有其他替代的不确定性，先将它们使用’_’通配符进行匹配，匹配的符号re.compile(ur&#39;[-+・\\&#39;!-:.\\(\\)\\s]&#39;) ， 这里还少了个 ‘～’，因为使用正则表达式替换会出现替换两次的问题，我就使用replace函数进行替换了。 考虑到空格的不确定性，直接使用’%’通配符替换了标题中的所有空格 考虑到副标题的问题，在标题首尾加上’%’通配符 最后再找不到就来一次将特殊字符全部替换成’%’的匹配 前后最多匹配10次，如果在匹配中出现了多个结果就直接手工填充了，代码。（注意下，最好将查找的字段添加上索引，不然可能要搜索个几分钟） 除了标题其实还有一个特征值：放送时间。但是通过bgm网页上获取的放送时间是中文形式的，需要去format才能和其他网站匹配。后来一想bgm不还有api吗，看了下api的属性里果然有air_date的标准形式，也可以拿来筛选。 目前的进度第一次用程序匹配完，4000多项数据填了3000多项，结果还是不够理想，毕竟剩下1000项数据也没法手工填。于是我干脆就先删除无用数据吧，sati上评论数少于20的就不去考虑了，删了一圈，并用放送时间进行了一圈匹配（将时间相同的输出，手工填），剩下1000多项数据，其中85项未填，看了下未填项，还真是有很多坑啊。 （第一条全角空格没考虑，第二条两个网站的字竟然不一样，第三条sati上使用了汉字而bgm上的日文名使用了平假名） 目前还需要手工把剩下的数据填上了。","tags":[{"name":"动漫","slug":"动漫","permalink":"https://frezc.github.io/tags/动漫/"},{"name":"anime","slug":"anime","permalink":"https://frezc.github.io/tags/anime/"},{"name":"rank","slug":"rank","permalink":"https://frezc.github.io/tags/rank/"},{"name":"排行","slug":"排行","permalink":"https://frezc.github.io/tags/排行/"}]},{"title":"自己在Android开发中碰到的问题和解决办法","date":"2015-11-09T16:51:00.000Z","path":"2015/11/10/自己在Android开发中碰到的问题和解决办法/","text":"说起来android我已经半年多没碰过了，这次为了让小组成员会写网络请求和用design库，我还是自己动手写了网络请求的封装类和一个design库的demo。当然，还是不免遇到了一些问题。ps: 因为是前几天的事，也没截图，就随便记录一下啦。 项目升级看idea总提示我项目所用的支持库需要升级，于是第一件事当然是把build.gradle里引用库的版本号都改到最新了，还添加了design库的引用，然后就报错了。 一共有两个错误 资源重定义：搜了下发现是库里的命名冲突了，我这个项目中是com.zzt.inbox这个库和appcompat-v7间的冲突，前者并不会使用了，于是就直接移除了。 资源未找到：这个还是因为我只将支持库升级到了23.1.0，而sdk版本还停留在22的原因，将其改为23就ok了。 Intellij Idea 15看到idea升级到15了就马上去装了15，打开后直接是一个错误：jre未找到。我顺着错误中给出的路径：\\jre\\bin\\java.exe浏览了一下，发现这个路径就是错误的，实际上是\\jre\\jre\\bin\\java.exe。不知道我是不是个例。 当然解决方法很简单，在系统中安装一个自己的java就ok了，我由于没有安装32位的java所以idea自动使用了自带的java。最后我直接使用64位的idea就完全没问题了。 idea15的新特性我了解的不多，不过最直观的感受就是打开时稍微快了一点吧。 Context的空指针问题我在一个Activity中在某个变量初始化时调用了this.getApplicationContext()结果出现了空指针问题，当时我把这个函数放在onCreate()里后就好了。 后来我看到一篇关于Context的博客，才明白是怎么回事。 从上面这张图可以看出Activity只是一个装饰者，通过源码可以知道getApplicationContext()调用的还是其内部的一个ContextImpl对象。而这个对象是通过attachBaseContext(Context)这个函数传递给Activity的，所以在这个函数调用之前去调用getApplicationContext()自然会出现空指针异常了。","tags":[{"name":"android","slug":"android","permalink":"https://frezc.github.io/tags/android/"}]},{"title":"近期的一些琐事","date":"2015-11-08T17:01:00.000Z","path":"2015/11/09/近期的一些琐事/","text":"近几个星期真是莫名的忙啊，积累了不少事可以写写了，这篇文章就当做一个记录了。 创新实践课的安卓项目这些项目对于个人来说并不是十分积极去参与的，不过既然都当了组长还是要做好的。带着其他几个完全不懂的还是要干很多事啊。于是呢，我就干干设计app结构，设计api，写文档，然后写服务端（另一组不会写api，我就自己做了），现在还要操心app这边的网络请求管理。。 服务器端被某人推荐用Laravel+jwt+dingo去写了。laravel框架还是非常方便的，对于我这种没写过php但知道服务器端如何处理请求的人来说看完文档也就会做了；dingo这个插件并没有某人说的那么方便，虽然能直接返回数据自动生成json，但会像下面这样： {Entity: {&quot;xx&quot;: &quot;xx&quot;, ...}} 在外面多嵌套了一层，这样在app上解析时就不太方便了，于是最终还是使用response()-&gt;json()的方式。 机器视觉课的小组项目对于这种课都要做个项目我表示很吃惊，说实话我宁愿考试呢。其中翻译一篇长的要死的论文+做ppt就算了，还要小组做项目，我还是挺后悔选这门课的。不过既然不能换了，那还是要好好做的。 项目的题目是通过摄像头来监视交通系统，我选这个主要还是因为没有现成的加上挺有意思这两点吧。不过这样我的组员表示完全不懂了，想想到最后应该还是要我来设计算法吧。 这个项目我觉得还是挺有意思的，在十字路口通过双摄像头图像识别车辆的三维空间信息，然后就能十分精确的判断是否出现事故了，识别误差主要在图像到三维信息上。这个项目其实就一个问题，如何通过摄像机图像判断车辆中心点和矩形区域。这个我觉得可以使用模板对比的方法实现，但是对于一个尺寸的车辆还好，车辆模型一多工程量就会非常大了，总之还是有取巧的方法的，能给老师看看就够了。 软考吐槽下周六的软考吧。基础知识考的真是泛，计组、操作系统、数据库、软件工程、编译原理、设计模式、数据结构、算法分析、计网，我感觉以上全都有考到，对了还有门英语。虽然多，但都是选择题，应该能及格吧。 应用技术的考试我觉得就有意思多了，考的是系统设计（数据流图）、数据库设计（ER图）、软件设计（用例图、类图）、算法（很简单的求最长公共子串），还有道拿策略模式说话，实际就是简单的面向对象的多态编程。总的来说题还是出的不怎么样，有明显错误。 其他能把薄膜键盘敲出机器键盘的声音的室友早上8点起来敲代码这事已经在督促我早睡早起了！不然早上10点前我肯定睡不着了。（わらい）","tags":[]},{"title":"typecho上的第一篇博客","date":"2015-11-02T02:20:00.000Z","path":"2015/11/02/my-first-blog/","text":"自己撸了个域名后就决定换个地方写博客了，以前的博客点这访问。关于为什么要换地写呢，主要还是因为电脑装win10的时候把d盘格式化掉了，原来配置了挺长时间的博客配置（改了文件能用https访问，还用七牛做了国内的cdn）都没了，我也没劲再来一遍了，于是就干脆试试typecho吧。 从上学期Hackthon比赛后我就没怎么写过Android了，一直在学cocos2d-js和unity，毕竟我对游戏开发还是比较感兴趣的。现在只用Unity了，毕竟比起cocos包含了很多方便的工具，自己做做游戏的话会省事很多。近期为了创新实践的项目还写了个api服务器，不得不说Laravel框架在熟悉了后还是十分简单的，对于我这种没写过php的人都能写的行云流水啊。","tags":[]},{"title":"关于高级弹幕的一点心得和看法","date":"2015-07-20T08:33:33.000Z","path":"2015/07/20/Danmaku-code/","text":"假期实在没事做，参加了b站的第二届弹幕大赛玩玩，就做了个围住刀哥（这个审核不让过，就改名成ChatNoir了，连接）。这个游戏的逻辑很快就写好了，然后UI花了我几天时间。总之还是花了不少时间的，而且碰到了不少坑(未在文档里提及)，下面先谈谈这些坑。 ###坑首先我想吐槽的是b站提供的文档实在是糟糕，很多重要的api提都没提过，要自己去查ActionScript的api文档。还有虽然说是ECMAScript的标准，但有些地方却还是没有完美实现，比如结尾的分号省略会报错，函数的优先级问题等。下面说几点具体的: interval的第一个参数的函数内部不能声明变量，如果有声明变量的行为会没有任何提示的停止执行下去。 函数只能在声明后调用，而ECMAScript中对于函数声明会提前的。 数字数组的返回值不是数字类型。这样就有一个问题，数组下标不能嵌套，如a[b[0]]这里由于b[0]是字符串，返回的就是一个undefined了，如果要嵌套得a[parseInt(b[0])]这样。 对CommentField修改属性时，fontsize要放在textColor之前，不然后者会失效。这里的理由我也不清楚。 ###其他的建议和问题 ==元素的优先级==: 虽然在文档里没提到，这里面还是有绘制层次和优先级的。一般来说元素按添加进parent的顺序进行绘制，如果创建的时候没有带这个参数，那么父元素就是$.root，想修改绘制顺序可以调用父元素的setChildIndex(obj, index)进行修改。 ==绘图层次==: 利用好Canvas元素来将你的视图分层，每块区域都最好以同一个Canvas为父元素，由于元素的位置是相对于父元素定义的，这样在进行一些动画的时候就会方便很多。 ==鼠标的点击事件==: 我只发现Button这一个元素能响应鼠标的点击事件。如果要在你的弹幕中响应的话，可以在可能点击的区域放置一个透明的Button。还有另一种方法是使你想要响应点击事件的元素继承于Button，这种方法有一个好处：只有鼠标在该元素内部点击才响应，可以配合Shape进行一些复杂区域的响应判定而不用自己判断区域；当然有一个坏处：继承的元素同样会继承Button的阴影动画，这个我不知道怎么去掉，不过你背景是黑色的话这个不碍事。 ==得到鼠标位置==：这个不需要响应事件，每个元素都有mouseX和mouseY属性，这两个属性代表了鼠标当前相对于该元素的位置。 ==加载图片==：想要在弹幕里显示图片有两种方法，一个是矢量表示，一个是位图表示。有人写过将图片矢量化的工具，想显示分辨率比较高的图片这种方法比较合适。另一种就是将每个像素值放到代码里，利用BitmapData和Bitmap来显示，这种方法如果有as的开发环境就十分简单了，只要调用已有的api将图片的bytearray进行BASE64编码，将结果放到代码里，使用的时候解码调用setPixels就行了，或者直接将每个像素值放到一个数组里再到代码里利用setPixel一个个设置，后者应该会慢很多吧。 ###自己的一些看法高级弹幕的api还不是很完善，很多地方用的都是ActionScript里的东西，没有封装好。这样对于html5的播放器来说不是个好消息，如果有谁能完善这方面的话就好了。","tags":[{"name":"game","slug":"game","permalink":"https://frezc.github.io/tags/game/"},{"name":"bilibili","slug":"bilibili","permalink":"https://frezc.github.io/tags/bilibili/"},{"name":"弹幕","slug":"弹幕","permalink":"https://frezc.github.io/tags/弹幕/"},{"name":"ActionScript","slug":"ActionScript","permalink":"https://frezc.github.io/tags/ActionScript/"}]},{"title":"使用intellij的模板（live template）","date":"2015-06-07T12:42:45.000Z","path":"2015/06/07/use-intellij-live-template/","text":"intellij的live template功能十分强大，可以简化很多重复的代码，可以说是使用好intellij必会的一个东西。 ##什么是live templatelive template相当于一个代码块的缩写在编辑代码的过程中按下Ctrl+j可以查看当前上下文中可用的所有模板，下面是一些可能常用的模板（可以不用上面的快捷键，直接打出缩写会出现提示）。psvm: public static void main(String[] args){ } psfi、psfs: public static final int public static final String sout、soutv: System.out.println($END$); System.out.println(&quot;$EXPR_COPY$ = &quot; + $EXPR$); //这里是指打印类中的一个变量 ##live template是如何生成的在Settings -&gt; Editor -&gt; Code Style -&gt; Live Templates里可以查看并修改所有的模板，当然也能自己创建。我们先看看output下的soutm是怎么写的 System.out.println(&quot;$CLASS_NAME$.$METHOD_NAME$&quot;); 这个模板是用来生成打印当前类和方法名的，这里面有两个变量$CLASS_NAME$和$METHOD_NAME$，点击右边的Edit variables来看看它们是怎么定义的。 在Edit Template Variables对话框中可以看到这两个变量，通过每列的标题就知道是干什么的了，这里主要注意两点： 变量是有顺序的，idea会按顺序来生成这些变量，所以注意依赖关系。 Expression栏可以填双引号包含的字符串、其他已经定义的变量和预定义的函数，从下拉列表里可以选择预定义的函数。函数说明请参考官方文档 在预定义函数中有个十分强大的函数groovyScript(&quot;groovy code&quot;)，它可以执行groovy语句。比如模板soutp:System.out.println($FORMAT$);这里的变量$FORMAT$对应的Expression是 groovyScript(&quot;&#39;\\&quot;&#39; + _1.collect { it + &#39; = [\\&quot; + &#39; + it + &#39; + \\&quot;]&#39;}.join(&#39;, &#39;) + &#39;\\&quot;&#39;&quot;, methodParameters()) 稍微解释下这句，方法methodParameters()返回了当前方法参数的数组，这个数组对应着前面groovy语句中的_1，然后遍历_1，生成类似&quot;xxx = [&quot; + xxx + &quot;]...的java代码，多个之间使用,隔开，这句实际生成的代码如下: System.out.println(&quot;user = [&quot; + user + &quot;], isSave = [&quot; + isSave + &quot;]&quot;); ##自定义live template这里我自定义了一个live templatelim:Log.i(&quot;$END$&quot;,&quot;$CLASS_NAME$.$METHOD_NAME$:&quot; + $METHOD_PARAMETERS$);这个模板是用来生成将当前方法加参数名与值打印到Log的方法。其中$CLASS_NAME$:className()$METHOD_NAME$:methodName()$METHOD_PARAMETERS$:groovyScript(&quot;&#39;\\&quot;&#39; + _1.collect { it + &#39; = [\\&quot; + &#39; + it + &#39; + \\&quot;]&#39;}.join(&#39;, &#39;) + &#39;\\&quot;&#39;&quot;, methodParameters())$END$:上面的变量生成结束后光标停留位置建议把Skip if defined勾选，这样就不会询问你是否要更改上面的变量了。 ####优化上面的模板在输入完TAG后还要手动把光标移到语句尾，显得很麻烦，有没有办法再输入完TAG后回车直接进入下一行呢？ 当然是可以的，修改成如下即可： Log.i(&quot;$TAG$&quot;,&quot;$CLASS_NAME$.$METHOD_NAME$:&quot; + $METHOD_PARAMETERS$); $END$ 新增的$TAG$变量的Expression可以填你的初始值，如&quot;Test&quot;，如果你需要修改就不要勾选Skip if defined。这样在输入玩TAG后直接回车就能跳转到下一行了，是不是十分方便。 lim","tags":[{"name":"intellij idea","slug":"intellij-idea","permalink":"https://frezc.github.io/tags/intellij-idea/"},{"name":"live template","slug":"live-template","permalink":"https://frezc.github.io/tags/live-template/"}]},{"title":"用KJFrame的KJHttp请求无法加载图片","date":"2015-05-26T16:32:54.000Z","path":"2015/05/27/kjframe-http-loading-bitmap/","text":"KJFrame框架对Http请求和sqlite的ORM封装的挺简单实用的，所以前几天的hackathon比赛就用了这个框架，不过最后用KJHttp进行请求后，发现onSuccess(Bitmap t)接口似乎不会调用，最后也没测试时间了也就没解决这个问题了。 回过头来看看KJFram的源码发现@Override protected void deliverResponse(Map&lt;String, String&gt; headers, byte[] response) { if (mCallback != null) { mCallback.onSuccess(headers, response); } }和volley相同的方式调用HttpCallBack的public void onSuccess(Map&lt;String, String&gt; headers, byte[] t) { onSuccess(t); } public void onSuccess(byte[] t) { if (t != null) { onSuccess(new String(t)); } } public void onSuccess(String t) {} public void onSuccess(Bitmap t) {}很明显，这里你就算重写了onSuccess(Bitmap t)也不会调用。 看过源码后才发现有个KJBitmap类专门用来处理图片请求，并且使用的是BitmapCallBack&#x2F;** * 真正去加载一个图片 *&#x2F; private void doDisplay(final View imageView, final String imageUrl, int width, int height, final Drawable loadBitmap, final Drawable errorBitmap, final BitmapCallBack callback) { checkViewExist(imageView); imageView.setTag(imageUrl); BitmapCallBack mCallback = new BitmapCallBack() { @Override public void onPreLoad() { if (callback != null) { callback.onPreLoad(); } } @Override public void onSuccess(Bitmap bitmap) { if (imageUrl.equals(imageView.getTag())) { doSuccess(imageView, bitmap, loadBitmap); if (callback != null) { callback.onSuccess(bitmap); } } } @Override public void onFailure(Exception e) { doFailure(imageView, errorBitmap); if (callback != null) { callback.onFailure(e); } } @Override public void onFinish() { try { doLoadingViews.remove(imageView); } catch (Exception e) { } if (callback != null) { callback.onFinish(); } } }; if (imageUrl.startsWith(&quot;http&quot;)) { displayer.get(imageUrl, width, height, mCallback); } else { new DiskImageRequest().load(imageUrl, width, width, mCallback); } } 最后倒是想吐槽一下，把HttpCallBack里得到的byte[]数据转换成Bitmap调用onSucess(Bitmap t)不行吗。。","tags":[{"name":"android","slug":"android","permalink":"https://frezc.github.io/tags/android/"},{"name":"KJFrame","slug":"KJFrame","permalink":"https://frezc.github.io/tags/KJFrame/"},{"name":"http","slug":"http","permalink":"https://frezc.github.io/tags/http/"},{"name":"bitmap","slug":"bitmap","permalink":"https://frezc.github.io/tags/bitmap/"}]},{"title":"对于日本动漫的一些感想","date":"2015-05-18T16:50:42.000Z","path":"2015/05/19/japan-anime-reflections/","text":"这篇是作为自己的毛概作业写的，个人的一点拙见 这两年随着bilibili这类弹幕网站的发展，ACG文化似乎也更多的走进了大众的视野，人们对日本动漫的认识也不像几年前那样被问到看什么动画时回答的永远是那么几个：“火影，海贼，柯南，……”。现在的有越来越多的人知道了还有新番 这个东西，这个从现在各大网站的新番点击量就可以看出，现在挺火的《FATE/STAY NIGHT -UBW-》在b站上每集都有150万左右的点击，在两年前的新番动画可没这么多人看。当然在这里不仅仅讨论新番，整个日本的动漫为何这么受全世界欢迎呢，我就作为一个爱好者发表下自己所了解的东西。另外我也会谈谈前段时间文化部禁播了很多动画这事。 凛 在很多日本动漫中会出现“日本变成殖民地，改名11区” ，这样日本被灭的设定，因为太多见了，所以每次都会有人来吐槽：“日本又灭亡了啊”。去年的夏季番《东京残响》 甚至还描写了少年制造恐怖袭击的情节，这些情节我想在国内是不可能让我们看到的；还有《回转企鹅罐》故事的核心围绕着东京地铁毒气事件展开，可谓是挖了日本人的一个伤疤。日本动漫这种自由表达的风格肯定是在国内受欢迎的一点，毕竟都喜欢看看不同的东西。在13年有部火遍全球的动画《进击的巨人》，先不谈优秀的制作，这部动画这么火其实很明显，一是符合大众口味的类型，它和火影海贼其实可以分为一类，都是热血动漫，这类在国内的观众可是非常多的，第二就是比较血腥的情节了，对平时没接触过的人来说反而觉得更新颖 ，大众都喜欢跟风的特性，之后这类动画就变的挺受欢迎了(像去年的《火星异种》、《东京食尸鬼》等)，当然今年都进了文化部的黑名单。（说起来宫崎骏还表明过自己想制作《寄生兽》的动画，不过很难想象吉卜力如何来改编这种血腥暴力的漫画）不单单是自由，日本动漫几乎什么类型都会涉及，对于每个人来说总会有自己喜欢的。 himari 有很多热血战斗类型的动漫主人公都是初中生或高中生并非偶然，而是编剧认真考虑过的，有个词叫中二病 ，对于少年总会幻想过打败坏蛋然后拯救世界的情节，将年龄设为这个时期的少年也是能引起一定的共鸣吧。不仅仅是这类，有很多动漫可谓是道出了人心中的疙瘩。去年有部动画叫《乒乓》，虽然是运动题材的动画，但是讲的并不是主角多么努力然后赢得冠军的故事，而是指出挺现实的一点“天赋比努力重要”，很多人能从片中的角色看到自己的身影吧，这里有个挺不错的评论我认同 @Lawrence Li的说法，天赋比努力重要。但我不认同这是这部影片所传递出来得价值观，我觉得，最重要的是要找到属于自己的路，世界冠军也好，球馆教练也罢，本质上都相同，都只是世界上的某一个职业。钱啊、名声啊、荣誉啊、尊严啊，都是超出乒乓球之外的东西，这才是如梦幻泡影，如露亦如电。当你热切的追求某个事物，而它又让你感到深深的疲惫与痛苦时，那一定是走错了路。恶魔嫉妒星野的一切，他打的是嫉妒。龙一练球时从没笑过，他在打家人的尊严。孔文革因犯错被调整，他打的是忿恨。星野没觉悟之前，打的是自负。你会发现没人在打乒乓球，都在打虚妄，不自觉的就陷入到里面。 直到失败让他们意识到，原来我只是想打球啊。于是，有人放下了球，有人捡起了球。 无所谓天赋，时刻认清自己是谁，自己在干什么，这才是最重要的。 像我等天资平庸之辈，凭着努力达到自己的上限，就够了。 温新宇如何解读《乒乓》这部动画？和其他媒介一样，正是有能让人产生共鸣的东西，才能吸引人在其中。 乒乓 提起日本动漫，就不得不谈谈科幻这类型的作品。攻壳机动队(Ghost in the Shell)知道的人可能不多，但是黑客帝国(Matrix)大家都耳熟能详吧，在wiki上能发现这样一句话：Japanese director Mamoru Oshii’s Ghost in the Shell was a strong influence.[21] Producer Joel Silver has stated that the Wachowskis first described their intentions for The Matrix by showing him that anime and saying, “We wanna do that for real”. The Matrix (franchise)en.wikipedia.org/wiki/The_Matrix_(franchise)不仅是黑客帝国，近年来的《盗梦空间》 等美国大片都能看到日本动漫的身影，卡梅隆也说过要将日本漫画《铳梦》拍成电影（希望他没忘记）。科幻类型的小说是适合做成动画的，事实也正是如此，比起在电影中用各种特技支撑的场景，动画中能表现地更自然宏大。日本的科幻动画正是一大特色，一直以来都很不少的fans，像高达这样的超级机器人影响力不小，13年美国有部电影《环太平洋》在片尾向富野由悠季（《机动战士高达》创始人）、永进豪（《魔神Z》动画创始人）等人致敬。作为一个科幻fans，如果有人推荐我现在的好莱坞科幻大片的话，我肯定会向他推荐更值得一看的日本科幻动画(《攻壳机动队》或者12年的《来自新世界》)。关于日本科幻可以看看这个公开课–科幻概论。 自新世界 接下来说说禁播动漫的事，前段时间文化部禁了一堆日本动漫，原因是暴力、凶杀、色情和恐怖的动漫作品，引起了很多爱好者不满。仔细看看公布的一些名单，基本上带有负面情绪、见血的、有些许裸露镜头的，总的来说就是不适合小孩子看的都不行，实际上也是如此。在日本，虽然这些动漫作为TV动画应该都是全年龄的，但是由于并不是面向低年龄人群，所以都是作为深夜档播放，在网上看到这么一种说法： 黄金档”和“深夜档”。一般观念认为，黄金档多是商业快餐作品，而深夜档则是注重暴力和挑逗、大打“擦边球”的给成人看的动画。其实这种说法也不尽然。实际上，日本电视动画经过多年的发展，如今已形成一套关于档期分段的基本框架：晚上8点半至10点半是“黄金时段”，播放面向青少年或老少咸宜的动画；深夜时分播放面向高中及以上至成人的动画；周六、日上午播放面向儿童的动画。作品年龄区十分明晰，而且实行多年。 曾近就有因不适合在黄金档播放而被举报后调到深夜档播放的动画的例子，所以即使在日本，这些动画也并不是完全没有限制。而到了中国，电视上是不可能放了，就有了很多视频网站买了播放权 让人免费看，在中国这个网络如此普及，从小学就开始上网的国家 ，把这些动画放在网络上暴露给孩子我也觉得不妥。但是封禁这样的处理并不好，一是不利于国内动漫产业发展，毕竟从现在国内动漫发展看，基本上还是学日本来的，如果能在这方面和日本加深关系，多多学习还是有好处的；二是这样做的意义只有一个，就是能防止孩子找动画看而无意点到这些动漫，毕竟对于有心人，总能下载到的。我认为比起公开封禁，不如监督各个视频网站做好信息过滤（对于不适合孩子看的内容能实行会员制），对于有网络视听许可证的网站来说，也不可能不配合吧(笑)。对于这件事，文化部处理地不好，大众的反应也不能说正确，但是从中有能让人反思的事：“我们是不是也应该将制作成年人喜爱的动画”。对于这事现在很多网络公司已经行动起来了，不过政府也仅是以“国产动画”的名义支持。另外政府也应该早点把各媒体的分级制度制订好了，有了明确的制度引导才能有正确合理的判断。 说到底，动漫、电影、小说之类的本就没有太大差别，动漫受欢迎也是正常的，只是有了更多人接受了这种表现方式，一个好的作品无论是改编成什么都会很好看的（当然前提是能还原）。除了宫崎骏的动画，何不换换口味看看今敏、大友克洋、新海诚等导演的动画呢？ 写完后发现没提到过gal相关的，不过思来想去gal的改编其实都不太适合大众，哪怕是key社，也不能说所有人都有可能会喜欢吧。Narcissu倒是适合所有人，不过它不是gal哦。","tags":[{"name":"感想","slug":"感想","permalink":"https://frezc.github.io/tags/感想/"},{"name":"动漫","slug":"动漫","permalink":"https://frezc.github.io/tags/动漫/"},{"name":"日本动漫","slug":"日本动漫","permalink":"https://frezc.github.io/tags/日本动漫/"}]},{"title":"Gradle的preDexDebug错误的解决办法(大概)","date":"2015-05-15T17:47:14.000Z","path":"2015/05/16/solve-preDexDebug/","text":"今天把项目pull下来然后用intellij执行时出现了以下的错误提示 Error:Gradle: Execution failed for task &#39;:app:preDexDebug&#39;. &gt; com.android.ide.common.process.ProcessException: org.gradle.process.internal.ExecException: Process &#39;command &#39;C:\\Program Files\\Java\\jdk1.8.0_40\\bin\\java.exe&#39;&#39; finished with non-zero exit value 1 因为没有错误提示，只好去网上找解决方法。这时还是不得不感叹stackoverflow这网站的强大啊。 两个小时内试了n多方法都没成效，其中也试过把项目回滚，发现即使回滚也会有这个错误，很明显这不是项目本身的问题，大概是gradle哪里出现了问题。 总之，两个小时后在一次电脑当机重启后就莫名其妙地好了，我这里就讲讲我改过什么吧，也许可以当作参考。 升级sdk的build-tools和support library到最新(反正全部保持最新) 项目里引用了一个库，是以project形式引用的，将这个库的build.gradle里的compileSdkVersion之类的改成和项目app相同。 将项目和这个库的dependencies引用的库全部改成最新的，v4、v7这些intellij会出现提示，而CardView这些不会，需要手动改。 点击Build-Clean Project。(这个没关机前我就试过几遍，还是有错误) 终极大法，重启电脑。(我是电脑当掉了才重启，不然可能还要折腾很久)","tags":[{"name":"android","slug":"android","permalink":"https://frezc.github.io/tags/android/"},{"name":"intellij idea","slug":"intellij-idea","permalink":"https://frezc.github.io/tags/intellij-idea/"},{"name":"gradle","slug":"gradle","permalink":"https://frezc.github.io/tags/gradle/"}]},{"title":"如何结合Volley和Gson的使用","date":"2015-05-03T10:33:33.000Z","path":"2015/05/03/use-Volley-and-Gson/","text":"Volley和Gson都是谷歌开发的java库，一个处理网络请求，一个处理json，对于网络app来说这2个经常会一起使用，但谷歌似乎不考虑开发两者结合使用的api，所以就需要我们自己来写了。 自定义Request为了使请求能设置request体的参数，然后直接返回我们需要的对象，这时候需要重写Request，谷歌给出了一个重写Request的示例：public class GsonRequest&lt;T&gt; extends Request&lt;T&gt; { private final Gson gson = new Gson(); private final Class&lt;T&gt; clazz; private final Map&lt;String, String&gt; headers; private final Listener&lt;T&gt; listener; &#x2F;** * Make a GET request and return a parsed object from JSON. * * @param url URL of the request to make * @param clazz Relevant class object, for Gson&#39;s reflection * @param headers Map of request headers *&#x2F; public GsonRequest(String url, Class&lt;T&gt; clazz, Map&lt;String, String&gt; headers, Listener&lt;T&gt; listener, ErrorListener errorListener) { super(Method.GET, url, errorListener); this.clazz = clazz; this.headers = headers; this.listener = listener; } @Override public Map&lt;String, String&gt; getHeaders() throws AuthFailureError { return headers != null ? headers : super.getHeaders(); } @Override protected void deliverResponse(T response) { listener.onResponse(response); } @Override protected Response&lt;T&gt; parseNetworkResponse(NetworkResponse response) { try { String json = new String( response.data, HttpHeaderParser.parseCharset(response.headers)); return Response.success( gson.fromJson(json, clazz), HttpHeaderParser.parseCacheHeaders(response)); } catch (UnsupportedEncodingException e) { return Response.error(new ParseError(e)); } catch (JsonSyntaxException e) { return Response.error(new ParseError(e)); } } }如果需要设置参数，重写getParams()即可。 自定义数组json Request这里如果直接用List&lt;MyClass&gt;来作为 T 的类型是不对的，由于java的类型擦除机制，你从List&lt;MyClass&gt;获得的Class类是不包含MyClass信息的，gson解析时会抛出错误。 很明显这个GsonRequest无法处理数组形式的json，但是我又想用一个通用的类来处理数组形式的json，要怎么改呢。我这里提出几个方案供参考。 继承Request&lt;String&gt;在parseNetworkResponse里得到的response转换为字符串后放到Response.success()函数中返回然后在deliverResponse函数里将字符串转换为对象然后调用接口函数。不过我个人不喜欢这种做法，因为deliverResponse是在UI线程中处理的，解析非常大的json时可能会卡ui，我更喜欢把json的处理放在在工作线程中处理的parseNetworkResponse函数中。 分别处理我是将普通json和数组json分开处理，对于数组类型我传入的参数为 GsonRequest(Context context, int method, String url, Class&lt;T&gt; clazz, Map&lt;String,String&gt; headers, OnListResponseListener&lt;T&gt; listener, Response.ErrorListener errorListener) 这里我自定义了一个接口OnListResponseListener&lt;T&gt;，用于传递解析好的数组对象，Context对象是为了得到MainLooper，而使回调函数能在ui线程中进行，方便更新ui。然后设置一个数组标记isArray = true @Override protected Response&lt;T&gt; parseNetworkResponse(NetworkResponse networkResponse) { try { String json; if(&quot;gzip&quot;.equals(networkResponse.headers.get(&quot;Content-Encoding&quot;))) { json = NetWorkTool.GZipDecoderToString(networkResponse.data); }else { json = new String(networkResponse.data, HttpHeaderParser.parseCharset(networkResponse.headers)); } Log.i(&quot;GsonRequest&quot;,json); if(isArray){ final List&lt;T&gt; list = new ArrayList&lt;T&gt;(); JsonParser parser = new JsonParser(); JsonArray jsonArray = parser.parse(json).getAsJsonArray(); for(JsonElement obj : jsonArray){ T t = gson.fromJson(obj, clazz); list.add(t); } new Handler(context.getMainLooper()).post(new Runnable() { @Override public void run() { if (listListener != null) { listListener.onResponse(list); } } }); return Response.success(list.get(0), HttpHeaderParser.parseCacheHeaders(networkResponse)); }else { return Response.success(gson.fromJson(json, clazz), HttpHeaderParser.parseCacheHeaders(networkResponse)); } } catch (UnsupportedEncodingException e) { return Response.error(new ParseError(e)); } catch (JsonSyntaxException e) { return Response.error(new ParseError(e)); } } @Override protected void deliverResponse(T t) { if(listener != null) { listener.onResponse(t); } } parseNetworkResponse里先将返回的Gzip压缩的格式解码，再生成String，然后对于数组我是用过JsonParser转换成JsonArray再进行遍历生成每一个对象，最后在MainLooper里调用对应回调函数。 通过Type接口查看Gson的fromJson函数的源码 public &lt;T&gt; T fromJson(String json, Class&lt;T&gt; classOfT) throws JsonSyntaxException { Object object = fromJson(json, (Type) classOfT); return Primitives.wrap(classOfT).cast(object); } public &lt;T&gt; T fromJson(String json, Type typeOfT) throws JsonSyntaxException { if (json == null) { return null; } StringReader reader = new StringReader(json); T target = (T) fromJson(reader, typeOfT); return target; } 可见Gson终究是调用fromJson(StringReader , Type )来生成对象的，那么我们可以在创建GsonRequest时将传入Class&lt;T&gt;改为Type。对于json对象传入(Type)(MyClass.class)，对于json数组传入new TypeToken(ArrayList&lt;MyClass&gt;)(){}.getType()。如： request = new GsonRequest_&lt;ArrayList&lt;WeekSubjects&gt;&gt;(Request.Method.GET, NetParams.CALENDAR_URL, new TypeToken&lt;ArrayList&lt;WeekSubjects&gt;&gt;(){}.getType(),headers,this,this); Response.success调用时将获得的Obeject对象强制转换为 T。其他地方和原来一样即可。GsonRequest具体例子看 GsonRequest_","tags":[{"name":"android","slug":"android","permalink":"https://frezc.github.io/tags/android/"},{"name":"Volley","slug":"Volley","permalink":"https://frezc.github.io/tags/Volley/"},{"name":"Gson","slug":"Gson","permalink":"https://frezc.github.io/tags/Gson/"}]},{"title":"如何将你的项目上传到git远程库上","date":"2015-05-03T08:13:55.000Z","path":"2015/05/03/push-your-project-to-git/","text":"以前我以为git只能在远程库创建后pull下来再将项目复制进去才能上传。后来知道了原来可以直接通过创建本地仓库然后合并到远程仓库里，我这里通过SourceTree(简称st)来演示下操作。 创建远程库你可以在oschina、github或者其他提供git服务器的网站上创建，具体不演示了我在github上创建了一个项目 远程库 创建本地库点击st的克隆/新建选择创建新仓库标签，将目标路径设为你的项目根目录，点击创建 本地库 然后点击右上角的设置，在远程仓库选项卡里点击添加，将远程库的url复制到URL/路径里，远端名称建议和远程库名称相同，其他的自己填写，然后确定。 设置远程库 提交在你项目的选项卡里将未暂存文件暂存(建议这里在根目录写好.gitignore文件来忽略不必要上传的文件，具体怎么写去问谷歌百度) 暂存文件 然后点击提交(提交的作者和邮箱可以在工具-选项-默认用户信息里设置)，填写好提交信息，如果你勾选了立即推送变更到 - 则会在提交后马上执行push操作。 提交 如果没有勾选，这里点击推送，确定 推送 然后你的项目就上传到远程库了 成功 其他tips .gitignore要无视的文件和项目类型以及IDE有关，如果你用intellij idea写android项目，可以参考我的.gitignore 如果.gitignore如果无法忽视某些文件，请检查你的远程库上时候有这些文件，请提交一次删除这些文件后的项目，然后再更新.gitignore 一般来说你的远程库更新后st会自动检测到更新，如果没有请点击获取来的到更新，然后再通过拉取更新。","tags":[{"name":"git","slug":"git","permalink":"https://frezc.github.io/tags/git/"}]},{"title":"hexo使用经验分享","date":"2015-04-30T17:08:22.000Z","path":"2015/05/01/2015-05-01-hexo-share/","text":"首先感谢BranchZero的帮忙 hexo的确是很方便的博客框架，更改主题，写文章，同步什么的几句命令就搞定了，对于不想花太多时间搞这个的人来说是个省时利器。 hexo的配置也是十分简单,按照官网的文档可以十分轻松地解决当然第一次用还是遇到了一些问题，我也通过某些方法解决了，在这里分享一下。 npm墙内人民水深火热,这个不翻墙太难受了我用的是淘宝的NPM镜像速度非常不错, 按里面的配置就ok了使用时将所有 npm 命令改成 cnpm 即可 主题主题可以去官网或github上搜索hexo找到我使用的是yilia,毕竟简洁清晰。不过这个主题也有点问题，就是没考虑好兼容https，如果使用https则需要修改掉模板中http的一些js库引用: 首先是mathjax的库引用,因为我觉得不会用到这个功能,所以直接在_config.xml中将其设为false. 然后是主题文件夹/layout/_partial/head.ejs中的&lt;script src=&quot;http:&#x2F;&#x2F;libs.baidu.com&#x2F;jquery&#x2F;1.9.0&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt; 改为https下的jquery库引用 Deploywindows如果直接在目录下控制台中使用命令 hexo d 会出现错误heINFO Deploying: git INFO Clearing .deploy folder... INFO Copying files from public folder... events.js:85 throw er; &#x2F;&#x2F; Unhandled &#39;error&#39; event ^ Error: spawn git ENOENT at exports._errnoException (util.js:746:11) at Process.ChildProcess._handle.onexit (child_process.js:1053:32) at child_process.js:1144:20 at process._tickCallback (node.js:355:11)解决方法是使用Git Bash, 如果出现了Not a gitreposity错误, 则需要你手动在.deploy_git文件夹下创建git库, 然后就能上传了。远程git库地址在_config.yml中指定(详情见文档), 建议使用ssh地址, 这样配置好密钥后每次提交就不需要输入验证信息了。 提升访问速度hexo模板生成的文件基本是不变的, 可以将这些文件放到国内服务器上来增加访问速度。修改模板, 将引用地址改掉, 然后将生成文件放到服务器上就ok了。具体是由BranchZero帮忙的 ：D.","tags":[{"name":"hexo","slug":"hexo","permalink":"https://frezc.github.io/tags/hexo/"}]}]